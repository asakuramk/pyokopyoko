<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ãŠå®¶ã¸å¸°ã‚ã†ï¼šã´ã‚‡ã“ã´ã‚‡ã“ã‚¸ãƒ£ãƒ³ãƒ—</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #FFB6C1 0%, #FFC0CB 100%); /* ãƒ”ãƒ³ã‚¯è‰²ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ */
            font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
            touch-action: none;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .message-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px 45px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            pointer-events: auto;
            display: none;
            border: 4px solid #FFD93D;
            transform: scale(0.9);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        @keyframes popIn {
            to { transform: scale(1); }
        }
        h1 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 28px;
            text-shadow: 1px 1px 0 #FFF;
        }
        p {
            margin: 0 0 25px 0;
            color: #555;
            font-weight: bold;
            line-height: 1.5;
        }
        button {
            background: #FF6B6B;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 0 #D64545;
            transition: transform 0.1s, box-shadow 0.1s;
            pointer-events: auto;
            touch-action: manipulation;
        }
        button:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #D64545;
        }
        button:hover {
            opacity: 0.9;
        }
        #score-display {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            font-weight: bold;
            font-size: 22px;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.3);
            pointer-events: none;
            background: rgba(0,0,0,0.2);
            padding: 5px 15px;
            border-radius: 20px;
        }
        #volume-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255,255,255,0.8);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #controls-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="score-display">é«˜ã•: 0m</div>
    <button id="volume-btn" onclick="toggleMute()">ğŸ”Š</button>

    <div id="ui-layer">
        <!-- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ -->
        <div id="start-screen" class="message-box" style="display: block;">
            <h1>ğŸ  ãŠå®¶ã¸å¸°ã‚ã†</h1>
            <p style="font-size: 16px; color: #FF6B6B; font-weight: bold; margin-bottom: 10px;">v2.2 ğŸ“±Safariå¯¾å¿œå¼·åŒ–ï¼</p>
            <p>ã¡ã‚‡ã£ã¨é›£ã—ããªã£ãŸã‚ˆï¼<br>å‹•ãåºŠã‚„ã€å£Šã‚Œã‚‹åºŠã«æ°—ã‚’ã¤ã‘ã¦ï¼</p>
            <p style="font-size: 12px;">éŸ³ãŒå‡ºã¾ã™ ğŸ”Š</p>
            <button id="start-btn">ã‚¹ã‚¿ãƒ¼ãƒˆï¼</button>
        </div>

        <!-- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ -->
        <div id="gameover-screen" class="message-box">
            <h1 style="color: #FF6B6B;">è½ã¡ã¡ã‚ƒã£ãŸ...</h1>
            <p>ã‚ãã‚‰ã‚ãªã„ã§ï¼</p>
            <button id="retry-btn">ã‚‚ã†ä¸€å›ï¼</button>
        </div>

        <!-- ã‚¯ãƒªã‚¢ç”»é¢ -->
        <div id="win-screen" class="message-box">
            <h1 style="color: #4ECDC4;">ğŸ‰ ãŸã ã„ã¾ã£ï¼</h1>
            <p>ç„¡äº‹ã«ãŠå®¶ã«å¸°ã‚Œã¾ã—ãŸï¼<br>ã™ã”ã„ï¼ï¼</p>
            <button id="again-btn">ã¾ãŸéŠã¶</button>
        </div>
    </div>

    <div id="controls-hint">PC: çŸ¢å°ã‚­ãƒ¼ / ã‚¹ãƒãƒ›: ç”»é¢å·¦å³ã‚¿ãƒƒãƒ—</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let gameState = 'start';
        let animationId;

        // ã‚µã‚¦ãƒ³ãƒ‰ç®¡ç†
        let audioCtx = null;
        let isMuted = false;

        // AudioContextã®åˆæœŸåŒ–ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¾Œï¼‰
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function toggleMute() {
            isMuted = !isMuted;
            document.getElementById('volume-btn').innerText = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
        }

        // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆSafariå¯¾å¿œå¼·åŒ–ç‰ˆï¼‰
        function attachButtonHandlers() {
            const startBtn = document.getElementById('start-btn');
            const retryBtn = document.getElementById('retry-btn');
            const againBtn = document.getElementById('again-btn');
            
            function addClickHandler(btn, handler) {
                if (!btn) return;
                
                // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå„ªå…ˆï¼‰
                btn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    handler();
                }, { passive: false });
                
                // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                btn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    handler();
                }, { passive: false });
                
                // ã•ã‚‰ã«mousedownã‚‚è¿½åŠ 
                btn.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    handler();
                }, { passive: false });
            }
            
            addClickHandler(startBtn, startGame);
            addClickHandler(retryBtn, resetGame);
            addClickHandler(againBtn, resetGame);
        }

        const sounds = {
            jump: () => {
                if (isMuted || !audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            },
            break: () => {
                if (isMuted || !audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            },
            gameover: () => {
                if (isMuted || !audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.5);
            },
            win: () => {
                if (isMuted || !audioCtx) return;
                const now = audioCtx.currentTime;
                [0, 0.1, 0.2, 0.4].forEach((t, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'triangle';
                    const freq = [523.25, 659.25, 783.99, 1046.50][i]; // C E G C
                    osc.frequency.setValueAtTime(freq, now + t);
                    gain.gain.setValueAtTime(0.2, now + t);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + t + 0.4);
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start(now + t);
                    osc.stop(now + t + 0.5);
                });
            }
        };

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const GRAVITY = 0.4;
        const JUMP_FORCE = -11.5;
        const MOVE_SPEED = 5.5;
        const PLATFORM_HEIGHT = 18;
        const GOAL_HEIGHT = 6000;

        let player = {
            x: 0, y: 0, width: 34, height: 34, vx: 0, vy: 0,
            color: '#FFD93D',
            face: 'normal'
        };

        let camera = { y: 0 };
        let platforms = [];
        let particles = [];
        let clouds = [];
        let house = { x: 0, y: 0 };
        let maxScore = 0;
        let keys = { left: false, right: false };

        // èƒŒæ™¯ã®é›²
        function initClouds() {
            clouds = [];
            for(let i=0; i<15; i++) {
                clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    speed: 0.2 + Math.random() * 0.5,
                    size: 30 + Math.random() * 50,
                    opacity: 0.3 + Math.random() * 0.4
                });
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft') keys.left = true;
            if (e.code === 'ArrowRight') keys.right = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft') keys.left = false;
            if (e.code === 'ArrowRight') keys.right = false;
        });
        window.addEventListener('touchstart', (e) => {
            if(gameState !== 'playing') return;
            e.preventDefault();
            const touchX = e.touches[0].clientX;
            if (touchX < window.innerWidth / 2) {
                keys.left = true; keys.right = false;
            } else {
                keys.right = true; keys.left = false;
            }
        });
        window.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys.left = false; keys.right = false;
        });

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() - 0.5) * 6;
                this.life = 1.0;
                this.color = color;
                this.size = Math.random() * 4 + 2;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life -= 0.04;
                this.size *= 0.95;
            }
            draw(ctx, camY) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y - camY, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function initGame() {
            player.x = canvas.width / 2 - player.width / 2;
            player.y = canvas.height - 150;
            player.vx = 0; player.vy = 0;
            player.face = 'normal';

            camera.y = 0;
            maxScore = 0;
            particles = [];
            initClouds();

            platforms = [];
            // åˆæœŸè¶³å ´
            let prevX = canvas.width / 2 - 100;
            platforms.push({
                x: prevX, y: canvas.height - 50, w: 200, h: 20,
                type: 'normal', vx: 0
            });

            let currentY = canvas.height - 50;
            let level = 0; // é›£æ˜“åº¦ãƒ¬ãƒ™ãƒ«

            while (currentY > -GOAL_HEIGHT) {
                const gap = 70 + Math.random() * 60; // ç¸¦ã®é–“éš”
                currentY -= gap;

                // ãƒ¬ãƒ™ãƒ«è¨ˆç®— (é«˜ã•ã«å¿œã˜ã¦é›£æ˜“åº¦ã‚¢ãƒƒãƒ—)
                const height = canvas.height - currentY;
                level = Math.floor(height / 1000); // 1000mã”ã¨ã«ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—

                let w = 90 - (level * 5); // ã ã‚“ã ã‚“ç‹­ã
                if(w < 50) w = 50;
                w = w + Math.random() * 20;

                // æ¨ªä½ç½®ã®è¨ˆç®—ï¼ˆå±Šãç¯„å›²ã§ï¼‰
                let minX = Math.max(0, prevX - 280);
                let maxX = Math.min(canvas.width - w, prevX + 280);

                // è©°ã¿é˜²æ­¢
                if (maxX - minX < 60) {
                     if (prevX < canvas.width / 2) maxX = Math.min(canvas.width - w, minX + 350);
                     else minX = Math.max(0, maxX - 350);
                }

                let x = minX + Math.random() * (maxX - minX);

                // è¶³å ´ã‚¿ã‚¤ãƒ—æ±ºå®š
                let type = 'normal';
                let pVx = 0;

                const rand = Math.random();
                // é«˜ã•ãŒã‚ã‚‹ç¨‹åº¦ã‚ã‚‹å ´åˆã®ã¿ç‰¹æ®Šè¶³å ´å‡ºç¾
                if (height > 500) {
                    if (rand < 0.2 + (level * 0.05)) type = 'moving';
                    else if (rand < 0.35 + (level * 0.05)) type = 'fragile';
                }

                if (type === 'moving') {
                    pVx = (Math.random() < 0.5 ? -1 : 1) * (2 + Math.random() * 2);
                }

                platforms.push({
                    x: x, y: currentY, w: w, h: PLATFORM_HEIGHT,
                    type: type, vx: pVx,
                    active: true // fragileç”¨
                });

                prevX = x;
            }

            house = {
                x: canvas.width / 2 - 50,
                y: -GOAL_HEIGHT - 120,
                w: 100, h: 100
            };

            platforms.push({
                x: canvas.width / 2 - 150, y: -GOAL_HEIGHT,
                w: 300, h: 20, type: 'goal', vx: 0
            });
        }

        function update() {
            if (gameState !== 'playing') return;

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•
            if (keys.left) player.vx = -MOVE_SPEED;
            else if (keys.right) player.vx = MOVE_SPEED;
            else player.vx *= 0.8;

            player.x += player.vx;

            if (player.x + player.width < 0) player.x = canvas.width;
            if (player.x > canvas.width) player.x = -player.width;

            player.vy += GRAVITY;
            player.y += player.vy;

            // è¡¨æƒ…åˆ¶å¾¡
            if(player.vy < -5) player.face = 'jump';
            else if(player.vy > 5) player.face = 'fall';
            else player.face = 'normal';

            // è¶³å ´ã®ç§»å‹•
            platforms.forEach(p => {
                if (p.type === 'moving') {
                    p.x += p.vx;
                    if (p.x <= 0 || p.x + p.w >= canvas.width) {
                        p.vx *= -1;
                    }
                }
            });

            // å½“ãŸã‚Šåˆ¤å®š
            if (player.vy > 0) {
                for (let i = 0; i < platforms.length; i++) {
                    let p = platforms[i];
                    if (!p.active && p.type === 'fragile') continue; // å£Šã‚ŒãŸè¶³å ´ã¯ç„¡è¦–

                    if (
                        player.x + player.width > p.x &&
                        player.x < p.x + p.w &&
                        player.y + player.height > p.y &&
                        player.y + player.height < p.y + p.h + player.vy + 2
                    ) {
                        player.y = p.y - player.height;
                        player.vy = JUMP_FORCE;

                        sounds.jump(); // éŸ³é³´ã‚‰ã™
                        createParticles(player.x + player.width/2, player.y + player.height, '#FFF');

                        // å£Šã‚Œã‚‹è¶³å ´ã®å‡¦ç†
                        if (p.type === 'fragile') {
                            p.active = false; // æ¬¡ã‹ã‚‰ä¹—ã‚Œãªã„
                            sounds.break();
                            createParticles(p.x + p.w/2, p.y + p.h/2, '#A0522D');
                        }
                    }
                }
            }

            const targetCamY = player.y - canvas.height / 2;
            if (targetCamY < camera.y) {
                camera.y = targetCamY;
            }

            const currentHeight = Math.floor((canvas.height - player.y) / 10);
            if (currentHeight > maxScore) maxScore = currentHeight;
            document.getElementById('score-display').innerText = `é«˜ã•: ${maxScore}m / ã‚´ãƒ¼ãƒ«: ${Math.floor((canvas.height - house.y)/10)}m`;

            if (
                player.x < house.x + house.w &&
                player.x + player.width > house.x &&
                player.y < house.y + house.h &&
                player.y + player.height > house.y
            ) {
                gameWin();
            }

            if (player.y > camera.y + canvas.height + 100) {
                gameOver();
            }

            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => p.update());

            // é›²ã®ç§»å‹•
            clouds.forEach(c => {
                c.x += c.speed;
                if(c.x > canvas.width + 50) c.x = -50;
            });
        }

        function draw() {
            // èƒŒæ™¯ã‚¯ãƒªã‚¢ & ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆãƒ”ãƒ³ã‚¯è‰²ï¼‰
            const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grad.addColorStop(0, '#FFB6C1');
            grad.addColorStop(1, '#FFC0CB');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ã‚²ãƒ¼ãƒ é–‹å§‹å‰ã¯æç”»ã—ãªã„
            if (gameState === 'start') return;

            // é›²æç”»
            clouds.forEach(c => {
                ctx.fillStyle = `rgba(255, 255, 255, ${c.opacity})`;
                ctx.beginPath();
                ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2);
                ctx.arc(c.x + c.size*0.7, c.y - c.size*0.3, c.size*0.8, 0, Math.PI * 2);
                ctx.arc(c.x + c.size*1.2, c.y + c.size*0.1, c.size*0.7, 0, Math.PI * 2);
                ctx.fill();
            });

            // è¶³å ´æç”»
            platforms.forEach(p => {
                if (p.y - camera.y > -50 && p.y - camera.y < canvas.height + 50) {
                    if (p.type === 'fragile' && !p.active) return; // å£Šã‚ŒãŸè¶³å ´ã¯æç”»ã—ãªã„

                    // è¶³å ´ã®è‰²è¨­å®š
                    let color = '#65B741'; // Normal: ç·‘
                    let shadow = '#4fa030';
                    if (p.type === 'moving') {
                        color = '#4FC3F7'; // Moving: é’
                        shadow = '#29B6F6';
                    } else if (p.type === 'fragile') {
                        color = '#D7CCC8'; // Fragile: èŒ¶/ãƒ™ãƒ¼ã‚¸ãƒ¥
                        shadow = '#A1887F';
                    }

                    // è§’ä¸¸ã®çŸ©å½¢
                    ctx.fillStyle = color;
                    roundRect(ctx, p.x, p.y - camera.y, p.w, p.h, 5, true, false);

                    // å½±
                    ctx.fillStyle = shadow;
                    roundRect(ctx, p.x, p.y - camera.y + p.h - 5, p.w, 5, 5, true, false);

                    // å£Šã‚Œã‚‹è¶³å ´ã®æ¨¡æ§˜
                    if (p.type === 'fragile') {
                        ctx.strokeStyle = '#A1887F';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(p.x + 10, p.y - camera.y + 2);
                        ctx.lineTo(p.x + p.w - 10, p.y - camera.y + p.h - 2);
                        ctx.stroke();
                    }
                    // å‹•ãè¶³å ´ã®æ¨¡æ§˜
                    if (p.type === 'moving') {
                         ctx.fillStyle = 'rgba(255,255,255,0.5)';
                         ctx.beginPath();
                         ctx.arc(p.x + 10, p.y - camera.y + p.h/2, 3, 0, Math.PI*2);
                         ctx.arc(p.x + p.w - 10, p.y - camera.y + p.h/2, 3, 0, Math.PI*2);
                         ctx.fill();
                    }
                }
            });

            // ã‚´ãƒ¼ãƒ«ï¼ˆãŠå®¶ï¼‰
            const houseScreenY = house.y - camera.y;
            // å£
            ctx.fillStyle = '#FFF8E1';
            ctx.fillRect(house.x, houseScreenY + 40, house.w, house.h - 40);
            // å±‹æ ¹
            ctx.fillStyle = '#FF5252';
            ctx.beginPath();
            ctx.moveTo(house.x - 15, houseScreenY + 40);
            ctx.lineTo(house.x + house.w / 2, houseScreenY);
            ctx.lineTo(house.x + house.w + 15, houseScreenY + 40);
            ctx.fill();
            // ãƒ‰ã‚¢
            ctx.fillStyle = '#795548';
            ctx.fillRect(house.x + house.w/2 - 15, houseScreenY + 60, 30, 40);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath(); ctx.arc(house.x + house.w/2 + 10, houseScreenY + 80, 3, 0, Math.PI*2); ctx.fill();

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»
            const playerScreenY = player.y - camera.y;
            ctx.fillStyle = player.color;
            let stretch = 1 + Math.abs(player.vy) * 0.03;
            if (stretch > 1.3) stretch = 1.3;
            let pWidth = player.width / stretch;
            let pHeight = player.height * stretch;

            // æœ¬ä½“
            roundRect(ctx, player.x + (player.width - pWidth)/2, playerScreenY + (player.height - pHeight), pWidth, pHeight, 8, true, false);

            // é¡”
            ctx.fillStyle = '#333';
            ctx.beginPath();
            let faceY = playerScreenY + (player.height - pHeight) + pHeight * 0.4;
            let centerX = player.x + player.width/2;
            let eyeOffset = 7;

            // ç›®
            if (player.face === 'fall') {
                // ï¼ï¼œ
                drawEye(ctx, centerX - eyeOffset, faceY, 'x');
                drawEye(ctx, centerX + eyeOffset, faceY, 'x');
            } else {
                // â— â—
                ctx.arc(centerX - eyeOffset, faceY, 3, 0, Math.PI*2);
                ctx.arc(centerX + eyeOffset, faceY, 3, 0, Math.PI*2);
            }
            ctx.fill();

            // å£
            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            if (player.face === 'jump') {
                ctx.arc(centerX, faceY + 5, 4, 0, Math.PI, false); // ç¬‘ã„å£
            } else if (player.face === 'fall') {
                ctx.arc(centerX, faceY + 8, 3, 0, Math.PI*2, false); // é©šãå£
            } else {
                ctx.moveTo(centerX - 3, faceY + 5);
                ctx.lineTo(centerX + 3, faceY + 5); // çœŸé¡”
            }
            ctx.stroke();

            // ã»ã£ãº
            ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(centerX - 12, faceY + 2, 4, 0, Math.PI*2);
            ctx.arc(centerX + 12, faceY + 2, 4, 0, Math.PI*2);
            ctx.fill();

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            particles.forEach(p => p.draw(ctx, camera.y));
        }

        // è§’ä¸¸çŸ©å½¢æç”»ãƒ˜ãƒ«ãƒ‘ãƒ¼
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            if (typeof stroke === 'undefined') { stroke = true; }
            if (typeof radius === 'undefined') { radius = 5; }
            if (typeof radius === 'number') { radius = {tl: radius, tr: radius, br: radius, bl: radius}; } else { var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0}; for (var side in defaultRadius) { radius[side] = radius[side] || defaultRadius[side]; } }
            ctx.beginPath();
            ctx.moveTo(x + radius.tl, y);
            ctx.lineTo(x + width - radius.tr, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
            ctx.lineTo(x + width, y + height - radius.br);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
            ctx.lineTo(x + radius.bl, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
            ctx.lineTo(x, y + radius.tl);
            ctx.quadraticCurveTo(x, y, x + radius.tl, y);
            ctx.closePath();
            if (fill) { ctx.fill(); }
            if (stroke) { ctx.stroke(); }
        }

        // ç›®æç”»ãƒ˜ãƒ«ãƒ‘ãƒ¼
        function drawEye(ctx, x, y, type) {
            ctx.beginPath();
            if (type === 'x') {
                ctx.moveTo(x - 3, y - 3);
                ctx.lineTo(x + 3, y + 3);
                ctx.moveTo(x + 3, y - 3);
                ctx.lineTo(x - 3, y + 3);
                ctx.stroke();
            }
        }

        // ã‚²ãƒ¼ãƒ é–‹å§‹
        function startGame() {
            initAudio();
            gameState = 'playing';
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('win-screen').style.display = 'none';
            initGame();
            if (animationId) cancelAnimationFrame(animationId);
            gameLoop();
        }

        // ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
        function resetGame() {
            initAudio();
            gameState = 'playing';
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('win-screen').style.display = 'none';
            initGame();
            if (animationId) cancelAnimationFrame(animationId);
            gameLoop();
        }

        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
        function gameOver() {
            gameState = 'gameover';
            sounds.gameover();
            document.getElementById('gameover-screen').style.display = 'block';
        }

        // ã‚¯ãƒªã‚¢
        function gameWin() {
            gameState = 'win';
            sounds.win();
            document.getElementById('win-screen').style.display = 'block';
        }

        // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
        function gameLoop() {
            update();
            draw();
            if (gameState === 'playing') {
                animationId = requestAnimationFrame(gameLoop);
            }
        }

        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«ãƒœã‚¿ãƒ³ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’è¨­å®šï¼ˆSafariå¯¾å¿œï¼‰
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(attachButtonHandlers, 100);
            });
        } else {
            setTimeout(attachButtonHandlers, 100);
        }
        
        // ã•ã‚‰ã«ç¢ºå®Ÿæ€§ã‚’é«˜ã‚ã‚‹ãŸã‚ã€loadã‚¤ãƒ™ãƒ³ãƒˆã§ã‚‚å®Ÿè¡Œ
        window.addEventListener('load', function() {
            setTimeout(attachButtonHandlers, 100);
        });

    </script>
</body>
</html>
