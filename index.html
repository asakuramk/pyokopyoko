<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ãŠå®¶ã¸å¸°ã‚ã† v1.0</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #A5D6A7;
            font-family: -apple-system, BlinkMacSystemFont, 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
        }
        #root {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        .game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .message-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px 50px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            pointer-events: auto;
            border: 5px solid #FFD93D;
            max-width: 90%;
        }
        .message-box h1 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 32px;
        }
        .message-box p {
            margin: 0 0 20px 0;
            color: #555;
            font-size: 16px;
            line-height: 1.6;
        }
        .version {
            font-size: 14px !important;
            color: #FF6B6B !important;
            font-weight: bold;
            margin-bottom: 5px !important;
        }
        .btn {
            background: #FF6B6B;
            color: white;
            border: none;
            padding: 15px 45px;
            font-size: 22px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 0 #D64545;
            transition: all 0.1s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        .btn:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #D64545;
        }
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .btn.secondary {
            background: #4FC3F7;
            box-shadow: 0 5px 0 #0288D1;
        }
        .score {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 8px 20px;
            border-radius: 25px;
            pointer-events: none;
        }
        .high-score {
            position: absolute;
            top: 55px;
            left: 15px;
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.25);
            padding: 6px 16px;
            border-radius: 20px;
            pointer-events: none;
        }
        .controls-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            pointer-events: none;
        }
        .update-time {
            position: absolute;
            top: 15px;
            right: 15px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 5px 15px;
            border-radius: 15px;
            pointer-events: none;
        }
        .name-input {
            width: 100%;
            padding: 12px 16px;
            border-radius: 12px;
            border: 2px solid #FFD93D;
            font-size: 16px;
            margin-bottom: 12px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function Game() {
            const canvasRef = useRef(null);
            const [gameState, setGameState] = useState('name');
            const [gameMode, setGameMode] = useState('pyoko');
            const [characterType, setCharacterType] = useState('human'); // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¿ã‚¤ãƒ—è¿½åŠ 
            const [playerName, setPlayerName] = useState('');
            const [nameInput, setNameInput] = useState('');
            const [players, setPlayers] = useState([]);
            const [highScores, setHighScores] = useState({
                pyoko: { name: '', score: 0 },
                crossy: { name: '', score: 0 },
                snake: { name: '', score: 0 }
            });
            const [crossyLevel, setCrossyLevel] = useState(1);
            const [score, setScore] = useState(0);
            const [totalScore, setTotalScore] = useState(0);
            const [isNewHighScore, setIsNewHighScore] = useState(false);
            const [highScoreMessage, setHighScoreMessage] = useState('');
            const gameLoopRef = useRef(null);
            const autoNextTimerRef = useRef(null);
            const getPlayerSize = (charType) => charType === 'human' ? 68 : 34;
            const getCrossyPlayerSize = (charType) => charType === 'human' ? 48 : 24;
            const gameDataRef = useRef({
                player: { x: 0, y: 0, vx: 0, vy: 0, width: 34, height: 34, state: 'jumping', animFrame: 0 },
                platforms: [],
                camera: { y: 0 },
                keys: { left: false, right: false },
                maxScore: 0,
                clouds: [],
                birds: [],
                poops: [],
                missiles: [],
                audioCtx: null,
                superJumpActive: false,
                scoreBonus: 0,
                crossy: {
                    player: { x: 0, y: 0, size: 24 },
                    cars: [],
                    trees: [],
                    laneHeight: 50,
                    laneCount: 8,
                    score: 0,
                    level: 1,
                    speedMultiplier: 1,
                    bloodSplatters: [],
                    isDying: false,
                    deathTimer: 0
                },
                snake: {
                    body: [],
                    direction: 'right',
                    nextDirection: 'right',
                    food: { x: 0, y: 0 },
                    gridSize: 20,
                    score: 0,
                    speed: 150,
                    lastMove: 0
                }
            });

            // --- ã“ã“ã«ç§»å‹• ---
            // é¤Œã‚’é…ç½®
            function spawnFood() {
                const data = gameDataRef.current;
                const snake = data.snake;
                const gridSize = snake.gridSize;
                const cols = Math.floor(window.innerWidth / gridSize);
                const rows = Math.floor(window.innerHeight / gridSize);

                let newFood;
                do {
                    newFood = {
                        x: Math.floor(Math.random() * cols),
                        y: Math.floor(Math.random() * rows)
                    };
                } while (snake.body.some(seg => seg.x === newFood.x && seg.y === newFood.y));

                snake.food = newFood;
            }

            // ã‚¹ãƒãƒ¼ã‚¯ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
            function initSnake() {
                const data = gameDataRef.current;
                const snake = data.snake;
                const gridSize = snake.gridSize;
                const cols = Math.floor(window.innerWidth / gridSize);
                const rows = Math.floor(window.innerHeight / gridSize);

                // è›‡ã®åˆæœŸä½ç½®ï¼ˆä¸­å¤®ä»˜è¿‘ï¼‰
                const startX = Math.floor(cols / 2);
                const startY = Math.floor(rows / 2);
                snake.body = [
                    { x: startX, y: startY },
                    { x: startX - 1, y: startY },
                    { x: startX - 2, y: startY }
                ];
                snake.direction = 'right';
                snake.nextDirection = 'right';
                snake.score = 0;
                snake.speed = 150;
                snake.lastMove = Date.now();

                // é¤Œã®é…ç½®
                spawnFood();
            }

            const GRAVITY = 0.4;
            const JUMP_FORCE = -11.5;
            const MOVE_SPEED = 5.5;
            const GOAL_HEIGHT = 6000;

            // ãƒã‚¤ã‚¹ã‚³ã‚¢é”æˆæ™‚ã®ãƒ©ãƒ³ãƒ€ãƒ çµ¶è³›ã‚³ãƒ¡ãƒ³ãƒˆ
            const highScoreComments = [
                'ğŸŠ ã™ã”ã™ãã‚‹ï¼ã‚ãªãŸã¯å¤©æ‰ã ï¼',
                'ğŸŒŸ ä¼èª¬ã®è¨˜éŒ²ã ï¼ç¥ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼èªå®šï¼',
                'ğŸ”¥ åœ§å€’çš„ï¼èª°ã‚‚æ­¢ã‚ã‚‰ã‚Œãªã„ï¼',
                'ğŸ’ ãƒ€ã‚¤ãƒ¤ãƒ¢ãƒ³ãƒ‰ç´šã®ãƒ—ãƒ¬ã‚¤ã ï¼',
                'ğŸš€ å®‡å®™æœ€å¼·ãƒ¬ãƒ™ãƒ«ï¼NASA ã‚‚æ³¨ç›®ï¼',
                'ğŸ‘‘ ç‹è€…é™è‡¨ï¼ã²ã‚Œä¼ã›çš†ã®è€…ï¼',
                'âš¡ é›»æ’ƒçš„ãªæ–°è¨˜éŒ²ï¼ç¨²å¦»ã®ã”ã¨ã—ï¼',
                'ğŸ¯ å®Œç’§ã™ãã‚‹ï¼100ç‚¹æº€ç‚¹ï¼',
                'ğŸ† ä¸–ç•ŒãŒéœ‡ãˆãŸï¼æ­´å²çš„ç¬é–“ï¼',
                'âœ¨ ã‚­ãƒ©ã‚­ãƒ©è¼ãæ–°è¨˜éŒ²ï¼çœ©ã—ã„ï¼',
                'ğŸ¦¸ ãƒ’ãƒ¼ãƒ­ãƒ¼èª•ç”Ÿï¼æ•‘ä¸–ä¸»ç¾ã‚‹ï¼',
                'ğŸª ã‚µãƒ¼ã‚«ã‚¹ã‚‚é©šãç¥æ¥­ãƒ—ãƒ¬ã‚¤ï¼',
                'ğŸŒˆ å¥‡è·¡ãŒèµ·ããŸï¼ä¼èª¬ã®å¹•é–‹ã‘ï¼',
                'ğŸ’« ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¹ã‚¿ãƒ¼çˆ†èª•ï¼ãƒ•ã‚¡ãƒ³æ€¥å¢—ä¸­ï¼',
                'ğŸ­ ãƒã‚¨ã‚¹ãƒˆãƒ­ï¼èŠ¸è¡“çš„ãªãƒ—ãƒ¬ã‚¤ï¼'
            ];

            const getRandomHighScoreComment = () => {
                return highScoreComments[Math.floor(Math.random() * highScoreComments.length)];
            };

            const computeHighScores = (list) => {
                const bestPyoko = list.reduce((acc, p) => {
                    return p.pyokoHigh > acc.score ? { name: p.name, score: p.pyokoHigh } : acc;
                }, { name: '', score: 0 });
                const bestCrossy = list.reduce((acc, p) => {
                    return p.crossyHigh > acc.score ? { name: p.name, score: p.crossyHigh } : acc;
                }, { name: '', score: 0 });
                const bestSnake = list.reduce((acc, p) => {
                    return (p.snakeHigh || 0) > acc.score ? { name: p.name, score: p.snakeHigh || 0 } : acc;
                }, { name: '', score: 0 });
                return { pyoko: bestPyoko, crossy: bestCrossy, snake: bestSnake };
            };

            const updatePlayerScore = (mode, newScore) => {
                if (!playerName) return;
                setPlayers(prev => {
                    const updated = [...prev];
                    const index = updated.findIndex(p => p.name === playerName);
                    if (index === -1) {
                        updated.push({
                            name: playerName,
                            pyokoHigh: mode === 'pyoko' ? newScore : 0,
                            crossyHigh: mode === 'crossy' ? newScore : 0,
                            snakeHigh: mode === 'snake' ? newScore : 0
                        });
                    } else {
                        if (mode === 'pyoko' && newScore > updated[index].pyokoHigh) {
                            updated[index].pyokoHigh = newScore;
                        }
                        if (mode === 'crossy' && newScore > updated[index].crossyHigh) {
                            updated[index].crossyHigh = newScore;
                        }
                        if (mode === 'snake' && newScore > (updated[index].snakeHigh || 0)) {
                            updated[index].snakeHigh = newScore;
                        }
                    }
                    setHighScores(computeHighScores(updated));
                    return updated;
                });
            };

            // éŸ³ã®æº–å‚™ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§å†é–‹ï¼‰
            const ensureAudio = () => {
                const data = gameDataRef.current;
                if (!data.audioCtx) {
                    data.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (data.audioCtx.state === 'suspended') {
                    data.audioCtx.resume();
                }
                return data.audioCtx;
            };

            useEffect(() => {
                const savedPlayers = JSON.parse(localStorage.getItem('players') || '[]');
                const lastName = localStorage.getItem('lastPlayerName') || 'ãƒˆãƒ ';
                setPlayers(savedPlayers);
                setHighScores(computeHighScores(savedPlayers));
                setNameInput(lastName);
                setPlayerName(lastName);
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã‘ã‚Œã°è¿½åŠ 
                if (!savedPlayers.some(p => p.name === lastName)) {
                    setPlayers(prev => [...prev, { name: lastName, pyokoHigh: 0, crossyHigh: 0 }]);
                }
                setGameState('title');
            }, []);

            useEffect(() => {
                localStorage.setItem('players', JSON.stringify(players));
                if (playerName) {
                    localStorage.setItem('lastPlayerName', playerName);
                }
            }, [players, playerName]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const resizeCanvas = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                return () => window.removeEventListener('resize', resizeCanvas);
            }, []);

            useEffect(() => {
                if (gameState !== 'playing') return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');

                // ã´ã‚‡ã“ã´ã‚‡ã“åˆæœŸåŒ–
                const initGame = () => {
                    const data = gameDataRef.current;
                    data.player.x = canvas.width / 2 - 17;
                    data.player.y = canvas.height - 150;
                    data.player.vx = 0;
                    data.player.vy = 0;
                    data.player.state = 'jumping';
                    data.player.animFrame = 0;
                    data.camera.y = 0;
                    data.maxScore = 0;
                    data.scoreBonus = 0;

                    // éŸ³ã®æº–å‚™ï¼ˆå®Ÿéš›ã®å†é–‹ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œæ™‚ã«è¡Œã†ï¼‰
                    if (!data.audioCtx) {
                        data.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    }

                    // é›²ã®åˆæœŸåŒ–
                    data.clouds = [];
                    for (let i = 0; i < 15; i++) {
                        data.clouds.push({
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height - Math.random() * GOAL_HEIGHT,
                            speed: 0.2 + Math.random() * 0.3,
                            size: 30 + Math.random() * 40
                        });
                    }

                    // é³¥ã®åˆæœŸåŒ–ï¼ˆç”»é¢ä»˜è¿‘ã«å‡ºç¾ï¼‰
                    data.birds = [];
                    for (let i = 0; i < 5; i++) {
                        data.birds.push({
                            x: Math.random() * canvas.width,
                            y: data.camera.y - 200 - Math.random() * 600,
                            vx: (Math.random() < 0.5 ? -1 : 1) * (1.5 + Math.random()),
                            size: 20,
                            poopTimer: 30 + Math.random() * 120
                        });
                    }

                    // ã†ã‚“ã¡é…åˆ—
                    data.poops = [];

                    // è¶³å ´ç”Ÿæˆ
                    data.platforms = [];
                    let prevX = canvas.width / 2 - 100;
                    data.platforms.push({
                        x: prevX, y: canvas.height - 50, w: 200, h: 20, type: 'normal'
                    });

                    let currentY = canvas.height - 50;
                    while (currentY > -GOAL_HEIGHT) {
                        const gap = 70 + Math.random() * 60;
                        currentY -= gap;

                        let w = 90 + Math.random() * 20;
                        let minX = Math.max(0, prevX - 280);
                        let maxX = Math.min(canvas.width - w, prevX + 280);
                        let x = minX + Math.random() * (maxX - minX);

                        data.platforms.push({
                            x: x, y: currentY, w: w, h: 20, type: 'normal'
                        });
                        prevX = x;
                    }

                    // ã‚´ãƒ¼ãƒ«
                    data.platforms.push({
                        x: canvas.width / 2 - 150, y: -GOAL_HEIGHT,
                        w: 300, h: 20, type: 'goal'
                    });
                };

                // ã‚¯ãƒ­ãƒƒã‚·ãƒ¼ãƒ­ãƒ¼ãƒ‰åˆæœŸåŒ–
                const initCrossy = () => {
                    const data = gameDataRef.current;
                    const crossy = data.crossy;
                    crossy.player.x = canvas.width / 2 - crossy.player.size / 2;
                    crossy.player.y = canvas.height - 60;
                    crossy.cars = [];
                    crossy.trees = [];
                    crossy.score = 0;
                    crossy.bloodSplatters = [];
                    crossy.isDying = false;
                    crossy.deathTimer = 0;
                    const laneHeight = crossy.laneHeight;
                    crossy.laneCount = Math.floor(canvas.height / laneHeight);
                    for (let i = 0; i < crossy.laneCount; i++) {
                        const y = canvas.height - (i + 2) * laneHeight;
                        const dir = i % 2 === 0 ? 1 : -1;
                        const speed = (2 + i * 0.2 + Math.random()) * crossy.speedMultiplier;
                        const carCount = 1 + (i % 2);
                        for (let c = 0; c < carCount; c++) {
                            crossy.cars.push({
                                x: Math.random() * canvas.width,
                                y,
                                w: 40,
                                h: 20,
                                vx: dir * speed
                            });
                        }
                    }

                    // æœ¨ï¼ˆéšœå®³ç‰©ï¼‰ã‚’è¿½åŠ 
                    const treeCount = 12;
                    for (let t = 0; t < treeCount; t++) {
                        crossy.trees.push({
                            x: Math.random() * (canvas.width - 30) + 5,
                            y: canvas.height - 120 - Math.random() * (crossy.laneCount * laneHeight - 40),
                            size: 22
                        });
                    }
                };

                if (gameMode === 'pyoko') {
                    initGame();
                } else if (gameMode === 'crossy') {
                    initCrossy();
                } else if (gameMode === 'snake') {
                    initSnake();
                }

                // éŸ³ã‚’é³´ã‚‰ã™é–¢æ•°
                const playSound = (type) => {
                    const audioCtx = ensureAudio();
                    if (!audioCtx) return;

                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();

                    if (type === 'jump') {
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                        gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.15);
                    } else if (type === 'gameover') {
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                        osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.5);
                        gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                        gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.5);
                    } else if (type === 'hit') {
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
                        gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.2);
                    }
                };

                // Web Speech Synthesis APIã§å£°ã‚’å‡ºã™
                const speakVoice = (text, pitch = 1, rate = 1.5) => {
                    if ('speechSynthesis' in window) {
                        // å‰ã®ç™ºè©±ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                        window.speechSynthesis.cancel();
                        const utterance = new SpeechSynthesisUtterance(text);
                        utterance.lang = 'ja-JP';
                        utterance.pitch = pitch;
                        utterance.rate = rate;
                        utterance.volume = 0.8;
                        window.speechSynthesis.speak(utterance);
                    }
                };

                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼åˆ¥ã®ã‚¸ãƒ£ãƒ³ãƒ—éŸ³ã‚’é³´ã‚‰ã™
                const playJumpVoice = (charType) => {
                    if (charType === 'dog') {
                        speakVoice('ãƒ¯ãƒ³', 1.2, 2.0);
                    } else if (charType === 'human') {
                        speakVoice('ãŠã‚Šã‚ƒãƒ¼', 0.8, 1.8);
                    } else if (charType === 'bird') {
                        speakVoice('ã‚³ã‚±ã‚³ãƒƒã‚³ãƒ¼', 1.5, 1.5);
                    } else {
                        playSound('jump');
                    }
                };

                // é¤Œã‚’é…ç½®
                const spawnFood = () => {
                    const data = gameDataRef.current;
                    const snake = data.snake;
                    const gridSize = snake.gridSize;
                    const cols = Math.floor(canvas.width / gridSize);
                    const rows = Math.floor(canvas.height / gridSize);

                    let newFood;
                    do {
                        newFood = {
                            x: Math.floor(Math.random() * cols),
                            y: Math.floor(Math.random() * rows)
                        };
                    } while (snake.body.some(seg => seg.x === newFood.x && seg.y === newFood.y));

                    snake.food = newFood;
                };

                // ã‚¹ãƒãƒ¼ã‚¯ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
                const initSnake = () => {
                    const data = gameDataRef.current;
                    const snake = data.snake;
                    const gridSize = snake.gridSize;
                    const cols = Math.floor(canvas.width / gridSize);
                    const rows = Math.floor(canvas.height / gridSize);

                    // è›‡ã®åˆæœŸä½ç½®ï¼ˆä¸­å¤®ä»˜è¿‘ï¼‰
                    const startX = Math.floor(cols / 2);
                    const startY = Math.floor(rows / 2);
                    snake.body = [
                        { x: startX, y: startY },
                        { x: startX - 1, y: startY },
                        { x: startX - 2, y: startY }
                    ];
                    snake.direction = 'right';
                    snake.nextDirection = 'right';
                    snake.score = 0;
                    snake.speed = 150;
                    snake.lastMove = Date.now();

                    // é¤Œã®é…ç½®
                    spawnFood();
                };

                // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
                const gameLoop = () => {
                    const data = gameDataRef.current;

                    // ã‚¹ãƒãƒ¼ã‚¯ã‚²ãƒ¼ãƒ 
                    if (gameMode === 'snake') {
                        const snake = data.snake;
                        const gridSize = snake.gridSize;
                        const cols = Math.floor(canvas.width / gridSize);
                        const rows = Math.floor(canvas.height / gridSize);
                        const now = Date.now();

                        // ç§»å‹•ã‚¿ã‚¤ãƒŸãƒ³ã‚°
                        if (now - snake.lastMove > snake.speed) {
                            snake.lastMove = now;
                            snake.direction = snake.nextDirection;

                            // é ­ã®æ–°ã—ã„ä½ç½®ã‚’è¨ˆç®—
                            const head = { ...snake.body[0] };
                            switch (snake.direction) {
                                case 'up': head.y -= 1; break;
                                case 'down': head.y += 1; break;
                                case 'left': head.x -= 1; break;
                                case 'right': head.x += 1; break;
                            }

                            // å£ã¨ã®è¡çªåˆ¤å®š
                            if (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows) {
                                playSound('hit');
                                updatePlayerScore('snake', snake.score);
                                setGameState('gameover');
                                return;
                            }

                            // è‡ªåˆ†è‡ªèº«ã¨ã®è¡çªåˆ¤å®š
                            if (snake.body.some(seg => seg.x === head.x && seg.y === head.y)) {
                                playSound('hit');
                                updatePlayerScore('snake', snake.score);
                                setGameState('gameover');
                                return;
                            }

                            // é¤Œã‚’é£Ÿã¹ãŸã‹
                            if (head.x === snake.food.x && head.y === snake.food.y) {
                                playSound('jump');
                                snake.score += 10;
                                setScore(snake.score);
                                snake.body.unshift(head);
                                spawnFood();
                                // ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—
                                if (snake.speed > 50) {
                                    snake.speed -= 2;
                                }
                            } else {
                                snake.body.unshift(head);
                                snake.body.pop();
                            }
                        }

                        // æç”»
                        // èƒŒæ™¯ï¼ˆæ¿ƒã„ç·‘ã®ã‚°ãƒªãƒƒãƒ‰ï¼‰
                        ctx.fillStyle = '#1a1a2e';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // ã‚°ãƒªãƒƒãƒ‰ç·š
                        ctx.strokeStyle = '#2a2a4e';
                        ctx.lineWidth = 1;
                        for (let x = 0; x <= canvas.width; x += gridSize) {
                            ctx.beginPath();
                            ctx.moveTo(x, 0);
                            ctx.lineTo(x, canvas.height);
                            ctx.stroke();
                        }
                        for (let y = 0; y <= canvas.height; y += gridSize) {
                            ctx.beginPath();
                            ctx.moveTo(0, y);
                            ctx.lineTo(canvas.width, y);
                            ctx.stroke();
                        }

                        // é¤Œï¼ˆã‚Šã‚“ã”ï¼‰
                        const foodX = snake.food.x * gridSize + gridSize / 2;
                        const foodY = snake.food.y * gridSize + gridSize / 2;
                        ctx.fillStyle = '#FF6B6B';
                        ctx.beginPath();
                        ctx.arc(foodX, foodY, gridSize / 2 - 2, 0, Math.PI * 2);
                        ctx.fill();
                        // ã‚Šã‚“ã”ã®è‘‰
                        ctx.fillStyle = '#4CAF50';
                        ctx.beginPath();
                        ctx.ellipse(foodX + 2, foodY - gridSize / 2 + 4, 4, 6, 0.5, 0, Math.PI * 2);
                        ctx.fill();

                        // è›‡ã®ä½“
                        snake.body.forEach((seg, i) => {
                            const x = seg.x * gridSize;
                            const y = seg.y * gridSize;

                            if (i === 0) {
                                // é ­
                                ctx.fillStyle = '#4CAF50';
                                ctx.fillRect(x + 1, y + 1, gridSize - 2, gridSize - 2);

                                // ç›®
                                ctx.fillStyle = '#FFF';
                                const eyeOffset = gridSize / 4;
                                let eye1X, eye1Y, eye2X, eye2Y;
                                switch (snake.direction) {
                                    case 'right':
                                        eye1X = x + gridSize - 6; eye1Y = y + 4;
                                        eye2X = x + gridSize - 6; eye2Y = y + gridSize - 8;
                                        break;
                                    case 'left':
                                        eye1X = x + 4; eye1Y = y + 4;
                                        eye2X = x + 4; eye2Y = y + gridSize - 8;
                                        break;
                                    case 'up':
                                        eye1X = x + 4; eye1Y = y + 4;
                                        eye2X = x + gridSize - 8; eye2Y = y + 4;
                                        break;
                                    case 'down':
                                        eye1X = x + 4; eye1Y = y + gridSize - 8;
                                        eye2X = x + gridSize - 8; eye2Y = y + gridSize - 8;
                                        break;
                                }
                                ctx.beginPath();
                                ctx.arc(eye1X + 2, eye1Y + 2, 3, 0, Math.PI * 2);
                                ctx.arc(eye2X + 2, eye2Y + 2, 3, 0, Math.PI * 2);
                                ctx.fill();
                            } else {
                                // ä½“
                                const shade = Math.max(0.5, 1 - i * 0.02);
                                ctx.fillStyle = `rgba(76, 175, 80, ${shade})`;
                                ctx.fillRect(x + 2, y + 2, gridSize - 4, gridSize - 4);
                            }
                        });

                        gameLoopRef.current = requestAnimationFrame(gameLoop);
                        return;
                    }

                    if (gameMode === 'crossy') {
                        const crossy = data.crossy;

                        // è¡€ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ›´æ–°ï¼ˆæ­»äº¡ä¸­ï¼‰
                        if (crossy.isDying) {
                            crossy.deathTimer--;
                            // è¡€é£›æ²«ã‚’åºƒã’ã‚‹
                            crossy.bloodSplatters.forEach(splat => {
                                splat.size += splat.growSpeed;
                                splat.alpha = Math.max(0, splat.alpha - 0.005);
                            });
                            if (crossy.deathTimer <= 0) {
                                crossy.isDying = false;
                                setGameState('gameover');
                            }
                        }

                        // è¡€é£›æ²«ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
                        const createBloodSplatters = (x, y) => {
                            crossy.bloodSplatters = [];
                            // å¤§é‡ã®è¡€é£›æ²«ã‚’ç”Ÿæˆ
                            for (let i = 0; i < 50; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = Math.random() * 150 + 50;
                                crossy.bloodSplatters.push({
                                    x: x + Math.cos(angle) * distance * 0.3,
                                    y: y + Math.sin(angle) * distance * 0.3,
                                    targetX: x + Math.cos(angle) * distance,
                                    targetY: y + Math.sin(angle) * distance,
                                    size: Math.random() * 20 + 10,
                                    growSpeed: Math.random() * 2 + 0.5,
                                    alpha: 0.9
                                });
                            }
                            // ä¸­å¿ƒã«å¤§ããªè¡€ã ã¾ã‚Š
                            crossy.bloodSplatters.push({
                                x: x,
                                y: y,
                                targetX: x,
                                targetY: y,
                                size: 60,
                                growSpeed: 3,
                                alpha: 1
                            });
                        };

                        // è¡€é£›æ²«ã®ä½ç½®ã‚’æ›´æ–°
                        crossy.bloodSplatters.forEach(splat => {
                            splat.x += (splat.targetX - splat.x) * 0.1;
                            splat.y += (splat.targetY - splat.y) * 0.1;
                        });

                        // è¡€æç”»é–¢æ•°
                        const drawBlood = () => {
                            crossy.bloodSplatters.forEach(splat => {
                                ctx.fillStyle = `rgba(139, 0, 0, ${splat.alpha})`;
                                ctx.beginPath();
                                ctx.arc(splat.x, splat.y, splat.size, 0, Math.PI * 2);
                                ctx.fill();

                                // é£›ã³æ•£ã£ãŸè¡€ã®ãƒ‰ãƒ­ãƒƒãƒ—
                                ctx.fillStyle = `rgba(180, 0, 0, ${splat.alpha * 0.7})`;
                                for (let d = 0; d < 3; d++) {
                                    const dropX = splat.x + (Math.random() - 0.5) * splat.size * 2;
                                    const dropY = splat.y + (Math.random() - 0.5) * splat.size * 2;
                                    ctx.beginPath();
                                    ctx.arc(dropX, dropY, Math.random() * 8 + 2, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            });

                            // ç”»é¢å…¨ä½“ã‚’èµ¤ãæŸ“ã‚ã‚‹
                            if (crossy.isDying) {
                                const redOverlay = Math.min(0.5, (60 - crossy.deathTimer) / 60 * 0.5);
                                ctx.fillStyle = `rgba(139, 0, 0, ${redOverlay})`;
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                            }
                        };

                        // è¡€é£›æ²«ã‚’æç”»ï¼ˆæ­»äº¡ä¸­ã®ã¿ï¼‰
                        const shouldDrawBlood = crossy.isDying || crossy.bloodSplatters.length > 0;

                        // è»Šã®æ›´æ–°
                        crossy.cars.forEach(car => {
                            car.x += car.vx;
                            if (car.vx > 0 && car.x > canvas.width + 60) car.x = -60;
                            if (car.vx < 0 && car.x < -60) car.x = canvas.width + 60;
                        });

                        // è¡çªåˆ¤å®šï¼ˆè»Šï¼‰- æ­»äº¡ä¸­ã¯ã‚¹ã‚­ãƒƒãƒ—
                        if (!crossy.isDying) {
                            crossy.cars.forEach(car => {
                                if (
                                    crossy.player.x + crossy.player.size > car.x &&
                                    crossy.player.x < car.x + car.w &&
                                    crossy.player.y + crossy.player.size > car.y &&
                                    crossy.player.y < car.y + car.h
                                ) {
                                    playSound('hit');
                                    // è¡€ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’é–‹å§‹
                                    createBloodSplatters(
                                        crossy.player.x + crossy.player.size / 2,
                                        crossy.player.y + crossy.player.size / 2
                                    );
                                    crossy.isDying = true;
                                    crossy.deathTimer = 90; // ç´„1.5ç§’é–“è¡€ã‚’è¡¨ç¤º
                                }
                            });
                        }

                        // è¡çªåˆ¤å®šï¼ˆæœ¨ï¼‰- æ­»äº¡ä¸­ã¯ã‚¹ã‚­ãƒƒãƒ—
                        if (!crossy.isDying) {
                            crossy.trees.forEach(tree => {
                                if (
                                    crossy.player.x + crossy.player.size > tree.x &&
                                    crossy.player.x < tree.x + tree.size &&
                                    crossy.player.y + crossy.player.size > tree.y &&
                                    crossy.player.y < tree.y + tree.size
                                ) {
                                    playSound('hit');
                                    setGameState('gameover');
                                }
                            });
                        }

                        // ã‚¹ã‚³ã‚¢
                        const currentCrossyScore = Math.max(0, Math.floor((canvas.height - crossy.player.y) / 10));
                        if (currentCrossyScore > crossy.score) {
                            crossy.score = currentCrossyScore;
                            setScore(currentCrossyScore);
                        }

                        // ã‚´ãƒ¼ãƒ«ï¼ˆç”»é¢ä¸Šç«¯ã«åˆ°é”ï¼‰
                        if (crossy.player.y <= 0) {
                            // ã‚¯ãƒªã‚¢æ™‚ã®ã‚¹ã‚³ã‚¢è¨ˆç®—ï¼ˆé¢ã‚¯ãƒªã‚¢ãƒœãƒ¼ãƒŠã‚¹è¿½åŠ ï¼‰
                            const levelBonus = crossyLevel * 10;
                            const newTotalScore = totalScore + crossy.score + levelBonus;
                            setTotalScore(newTotalScore);

                            // ãƒã‚¤ã‚¹ã‚³ã‚¢åˆ¤å®š
                            const currentHighScore = highScores.crossy.score;
                            if (newTotalScore > currentHighScore) {
                                setIsNewHighScore(true);
                                setHighScoreMessage(getRandomHighScoreComment());
                                updatePlayerScore('crossy', newTotalScore);
                            }

                            // ã‚¯ãƒªã‚¢æ™‚ã¯è‡ªå‹•çš„ã«æ¬¡ã®é¢ã¸é·ç§»
                            if (autoNextTimerRef.current) {
                                clearTimeout(autoNextTimerRef.current);
                            }
                            autoNextTimerRef.current = setTimeout(() => {
                                const data = gameDataRef.current;
                                data.crossy.level += 1;
                                data.crossy.speedMultiplier *= 1.2;
                                data.crossy.score = 0;
                                setCrossyLevel(data.crossy.level);
                                setScore(0);
                                setIsNewHighScore(false);
                                setGameState('playing');
                            }, 2500);
                            setGameState('win');
                        }

// æç”»ï¼ˆç”»é¢å…¨ä½“ã‚’é“è·¯ã§è¦†ã† - æ°´è‰²ã‚’å®Œå…¨ã«é™¤å»ï¼‰
                        const laneHeight = crossy.laneHeight;

                        // ã¾ãšç”»é¢å…¨ä½“ã‚’é“è·¯ã®è‰²ã§å¡—ã‚Šã¤ã¶ã™
                        ctx.fillStyle = '#616161';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // é“ã¨è‰ã®ã‚¹ãƒˆãƒ©ã‚¤ãƒ—ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¸Šã‹ã‚‰ä¸‹ã¾ã§å®Œå…¨ã«æç”»
                        for (let y = -laneHeight; y < canvas.height + laneHeight * 2; y += laneHeight) {
                            const laneIndex = Math.floor((y + laneHeight) / laneHeight);
                            ctx.fillStyle = laneIndex % 2 === 0 ? '#616161' : '#9CCC65';
                            ctx.fillRect(0, y, canvas.width, laneHeight);
                        }

                        // è»Šæç”»ï¼ˆãƒ†ã‚¹ãƒ©Model 3é¢¨ - ä¸Šã‹ã‚‰è¦‹ãŸè©³ç´°ãƒ‡ã‚¶ã‚¤ãƒ³ï¼‰
                        crossy.cars.forEach(car => {
                            const cx = car.x;
                            const cy = car.y;
                            const cw = car.w;
                            const ch = car.h;
                            const isRight = car.vx > 0;
                            const bodyColor = isRight ? '#E82127' : '#1565C0'; // ãƒ†ã‚¹ãƒ©ãƒ¬ãƒƒãƒ‰ or ãƒ‡ã‚£ãƒ¼ãƒ—ãƒ–ãƒ«ãƒ¼

                            ctx.save();

                            // è»Šä½“ã®ã‚·ãƒ£ãƒ‰ã‚¦
                            ctx.fillStyle = 'rgba(0,0,0,0.3)';
                            ctx.beginPath();
                            ctx.ellipse(cx + cw/2 + 2, cy + ch/2 + 2, cw/2 + 2, ch/2 + 1, 0, 0, Math.PI * 2);
                            ctx.fill();

                            // ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£ï¼ˆæµç·šå‹ã®ãƒ†ã‚¹ãƒ©ã‚·ãƒ«ã‚¨ãƒƒãƒˆï¼‰
                            ctx.fillStyle = bodyColor;
                            ctx.beginPath();
                            // å‰éƒ¨ï¼ˆä¸¸ã¿ã‚’å¸¯ã³ãŸãƒãƒ¼ã‚º - ãƒ†ã‚¹ãƒ©ç‰¹æœ‰ã®ã‚°ãƒªãƒ«ãƒ¬ã‚¹ï¼‰
                            ctx.moveTo(cx + cw * 0.05, cy + ch * 0.5);
                            ctx.quadraticCurveTo(cx, cy + ch * 0.3, cx + cw * 0.15, cy + ch * 0.1);
                            ctx.lineTo(cx + cw * 0.85, cy + ch * 0.1);
                            ctx.quadraticCurveTo(cx + cw, cy + ch * 0.3, cx + cw * 0.95, cy + ch * 0.5);
                            ctx.quadraticCurveTo(cx + cw, cy + ch * 0.7, cx + cw * 0.85, cy + ch * 0.9);
                            ctx.lineTo(cx + cw * 0.15, cy + ch * 0.9);
                            ctx.quadraticCurveTo(cx, cy + ch * 0.7, cx + cw * 0.05, cy + ch * 0.5);
                            ctx.closePath();
                            ctx.fill();

                            // ãƒœãƒ‡ã‚£ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆå…‰æ²¢æ„Ÿï¼‰
                            const gradient = ctx.createLinearGradient(cx, cy, cx, cy + ch);
                            gradient.addColorStop(0, 'rgba(255,255,255,0.3)');
                            gradient.addColorStop(0.5, 'rgba(255,255,255,0)');
                            gradient.addColorStop(1, 'rgba(0,0,0,0.2)');
                            ctx.fillStyle = gradient;
                            ctx.fill();

                            // ã‚¬ãƒ©ã‚¹ãƒ«ãƒ¼ãƒ•ï¼ˆãƒ†ã‚¹ãƒ©ç‰¹æœ‰ã®å¤§ããªã‚¬ãƒ©ã‚¹ï¼‰
                            ctx.fillStyle = '#1a1a2e';
                            ctx.beginPath();
                            ctx.moveTo(cx + cw * 0.2, cy + ch * 0.25);
                            ctx.lineTo(cx + cw * 0.8, cy + ch * 0.25);
                            ctx.quadraticCurveTo(cx + cw * 0.85, cy + ch * 0.5, cx + cw * 0.8, cy + ch * 0.75);
                            ctx.lineTo(cx + cw * 0.2, cy + ch * 0.75);
                            ctx.quadraticCurveTo(cx + cw * 0.15, cy + ch * 0.5, cx + cw * 0.2, cy + ch * 0.25);
                            ctx.closePath();
                            ctx.fill();

                            // ã‚¬ãƒ©ã‚¹ã®åå°„
                            ctx.fillStyle = 'rgba(135,206,235,0.3)';
                            ctx.beginPath();
                            ctx.moveTo(cx + cw * 0.25, cy + ch * 0.3);
                            ctx.lineTo(cx + cw * 0.5, cy + ch * 0.3);
                            ctx.lineTo(cx + cw * 0.45, cy + ch * 0.45);
                            ctx.lineTo(cx + cw * 0.25, cy + ch * 0.45);
                            ctx.closePath();
                            ctx.fill();

                            // ãƒ˜ãƒƒãƒ‰ãƒ©ã‚¤ãƒˆï¼ˆLEDé¢¨ï¼‰
                            ctx.fillStyle = '#FFFFFF';
                            ctx.beginPath();
                            ctx.ellipse(cx + cw * 0.08, cy + ch * 0.35, 2, 1.5, 0, 0, Math.PI * 2);
                            ctx.ellipse(cx + cw * 0.08, cy + ch * 0.65, 2, 1.5, 0, 0, Math.PI * 2);
                            ctx.fill();

                            // ãƒ†ãƒ¼ãƒ«ãƒ©ã‚¤ãƒˆï¼ˆãƒ†ã‚¹ãƒ©ç‰¹æœ‰ã®æ¨ªé•·LEDï¼‰
                            ctx.fillStyle = '#FF3333';
                            ctx.beginPath();
                            ctx.roundRect(cx + cw * 0.88, cy + ch * 0.3, 3, ch * 0.15, 1);
                            ctx.roundRect(cx + cw * 0.88, cy + ch * 0.55, 3, ch * 0.15, 1);
                            ctx.fill();

                            // Teslaãƒ­ã‚´ï¼ˆTãƒãƒ¼ã‚¯ï¼‰
                            ctx.fillStyle = '#C0C0C0';
                            ctx.font = 'bold 8px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('T', cx + cw * 0.5, cy + ch * 0.5);

                            // ãƒ›ã‚¤ãƒ¼ãƒ«ï¼ˆã‚¢ã‚¨ãƒ­ãƒ›ã‚¤ãƒ¼ãƒ«é¢¨ï¼‰
                            ctx.fillStyle = '#333';
                            ctx.beginPath();
                            ctx.arc(cx + cw * 0.25, cy + ch * 0.15, 3, 0, Math.PI * 2);
                            ctx.arc(cx + cw * 0.25, cy + ch * 0.85, 3, 0, Math.PI * 2);
                            ctx.arc(cx + cw * 0.75, cy + ch * 0.15, 3, 0, Math.PI * 2);
                            ctx.arc(cx + cw * 0.75, cy + ch * 0.85, 3, 0, Math.PI * 2);
                            ctx.fill();

                            // ãƒ›ã‚¤ãƒ¼ãƒ«ã®ãƒãƒ–ã‚­ãƒ£ãƒƒãƒ—
                            ctx.fillStyle = '#666';
                            ctx.beginPath();
                            ctx.arc(cx + cw * 0.25, cy + ch * 0.15, 1.5, 0, Math.PI * 2);
                            ctx.arc(cx + cw * 0.25, cy + ch * 0.85, 1.5, 0, Math.PI * 2);
                            ctx.arc(cx + cw * 0.75, cy + ch * 0.15, 1.5, 0, Math.PI * 2);
                            ctx.arc(cx + cw * 0.75, cy + ch * 0.85, 1.5, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.restore();
                        });

                        // æœ¨æç”»
                        crossy.trees.forEach(tree => {
                            ctx.fillStyle = '#6D4C41';
                            ctx.fillRect(tree.x + tree.size / 2 - 3, tree.y + tree.size / 2, 6, 10);
                            ctx.fillStyle = '#2E7D32';
                            ctx.beginPath();
                            ctx.arc(tree.x + tree.size / 2, tree.y + tree.size / 2, tree.size / 2, 0, Math.PI * 2);
                            ctx.fill();
                        });

                        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»ï¼ˆé¸æŠã—ãŸã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦æç”»ï¼‰
                        const basePx = crossy.player.x;
                        const basePy = crossy.player.y;
                        const baseSize = crossy.player.size;
                        // äººé–“ã¯2å€ã®ã‚µã‚¤ã‚ºã§æç”»
                        const pSize = characterType === 'human' ? baseSize * 2 : baseSize;
                        const px = basePx - (pSize - baseSize) / 2;
                        const py = basePy - (pSize - baseSize);
                        const centerX = px + pSize / 2;
                        const animFrame = Date.now() / 50;

                        if (characterType === 'human') {
                            // äººé–“ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
                            // ä½“ï¼ˆã‚ªãƒ¬ãƒ³ã‚¸è‰²ã®æœï¼‰
                            ctx.fillStyle = '#FF9800';
                            ctx.fillRect(px + pSize * 0.25, py + pSize * 0.35, pSize * 0.5, pSize * 0.5);

                            // é ­ï¼ˆè‚Œè‰²ï¼‰
                            ctx.fillStyle = '#FFCC99';
                            ctx.beginPath();
                            ctx.arc(centerX, py + pSize * 0.25, pSize * 0.2, 0, Math.PI * 2);
                            ctx.fill();

                            // ç›®
                            ctx.fillStyle = '#333';
                            ctx.fillRect(px + pSize * 0.4, py + pSize * 0.22, pSize * 0.08, pSize * 0.08);
                            ctx.fillRect(px + pSize * 0.52, py + pSize * 0.22, pSize * 0.08, pSize * 0.08);

                            // è…•
                            ctx.strokeStyle = '#FFCC99';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(px + pSize * 0.25, py + pSize * 0.45);
                            ctx.lineTo(px + pSize * 0.1, py + pSize * 0.6);
                            ctx.moveTo(px + pSize * 0.75, py + pSize * 0.45);
                            ctx.lineTo(px + pSize * 0.9, py + pSize * 0.6);
                            ctx.stroke();

                            // è„š
                            ctx.beginPath();
                            ctx.moveTo(px + pSize * 0.35, py + pSize * 0.85);
                            ctx.lineTo(px + pSize * 0.35, py + pSize);
                            ctx.moveTo(px + pSize * 0.65, py + pSize * 0.85);
                            ctx.lineTo(px + pSize * 0.65, py + pSize);
                            ctx.stroke();
                        } else if (characterType === 'bird') {
                            // é³©ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
                            const wingFlap = Math.sin(animFrame / 5) * 3;
                            // ä½“
                            ctx.fillStyle = '#9E9E9E';
                            ctx.beginPath();
                            ctx.ellipse(centerX, py + pSize * 0.6, pSize * 0.3, pSize * 0.35, 0, 0, Math.PI * 2);
                            ctx.fill();
                            // é ­
                            ctx.beginPath();
                            ctx.arc(centerX, py + pSize * 0.3, pSize * 0.18, 0, Math.PI * 2);
                            ctx.fill();
                            // ãã¡ã°ã—
                            ctx.fillStyle = '#FFA726';
                            ctx.beginPath();
                            ctx.moveTo(centerX, py + pSize * 0.3);
                            ctx.lineTo(centerX + pSize * 0.15, py + pSize * 0.28);
                            ctx.lineTo(centerX, py + pSize * 0.33);
                            ctx.closePath();
                            ctx.fill();
                            // ç›®
                            ctx.fillStyle = '#000';
                            ctx.beginPath();
                            ctx.arc(centerX - pSize * 0.05, py + pSize * 0.28, pSize * 0.04, 0, Math.PI * 2);
                            ctx.fill();
                            // ç¿¼
                            ctx.strokeStyle = '#757575';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(centerX - pSize * 0.3, py + pSize * 0.55);
                            ctx.lineTo(centerX - pSize * 0.45, py + pSize * 0.45 + wingFlap);
                            ctx.moveTo(centerX + pSize * 0.3, py + pSize * 0.55);
                            ctx.lineTo(centerX + pSize * 0.45, py + pSize * 0.45 + wingFlap);
                            ctx.stroke();
                        } else if (characterType === 'dog') {
                            // çŠ¬ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
                            // ä½“
                            ctx.fillStyle = '#8D6E63';
                            ctx.fillRect(px + pSize * 0.2, py + pSize * 0.55, pSize * 0.6, pSize * 0.3);
                            // é ­
                            ctx.beginPath();
                            ctx.arc(centerX, py + pSize * 0.38, pSize * 0.25, 0, Math.PI * 2);
                            ctx.fill();
                            // è€³
                            ctx.beginPath();
                            ctx.ellipse(centerX - pSize * 0.18, py + pSize * 0.32, pSize * 0.08, pSize * 0.15, -0.3, 0, Math.PI * 2);
                            ctx.ellipse(centerX + pSize * 0.18, py + pSize * 0.32, pSize * 0.08, pSize * 0.15, 0.3, 0, Math.PI * 2);
                            ctx.fill();
                            // ç›®
                            ctx.fillStyle = '#000';
                            ctx.beginPath();
                            ctx.arc(centerX - pSize * 0.1, py + pSize * 0.35, pSize * 0.05, 0, Math.PI * 2);
                            ctx.arc(centerX + pSize * 0.1, py + pSize * 0.35, pSize * 0.05, 0, Math.PI * 2);
                            ctx.fill();
                            // é¼»
                            ctx.beginPath();
                            ctx.arc(centerX, py + pSize * 0.45, pSize * 0.05, 0, Math.PI * 2);
                            ctx.fill();
                            // ã—ã£ã½
                            ctx.strokeStyle = '#8D6E63';
                            ctx.lineWidth = 3;
                            const tailWag = Math.sin(animFrame / 5) * 5;
                            ctx.beginPath();
                            ctx.moveTo(px + pSize * 0.8, py + pSize * 0.6);
                            ctx.lineTo(px + pSize * 0.95, py + pSize * 0.5 + tailWag);
                            ctx.stroke();
                        }

                        // è¡€ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’æç”»ï¼ˆæœ€å‰é¢ï¼‰
                        if (shouldDrawBlood) {
                            drawBlood();
                        }

                        gameLoopRef.current = requestAnimationFrame(gameLoop);
                        return;
                    }

                    // æ›´æ–°
                    if (data.keys.left) data.player.vx = -MOVE_SPEED;
                    else if (data.keys.right) data.player.vx = MOVE_SPEED;
                    else data.player.vx *= 0.8;

                    data.player.x += data.player.vx;
                    if (data.player.x + data.player.width < 0) data.player.x = canvas.width;
                    if (data.player.x > canvas.width) data.player.x = -data.player.width;

                    data.player.vy += GRAVITY;
                    data.player.y += data.player.vy;

                    // é›²ã®æ›´æ–°
                    data.clouds.forEach(c => {
                        c.x += c.speed;
                        if (c.x > canvas.width + 100) {
                            c.x = -100;
                            c.y = data.camera.y - 200 - Math.random() * 400;
                        }
                    });

                    // é³¥ã®æ›´æ–°
                    data.birds.forEach(bird => {
                        bird.x += bird.vx;
                        if (bird.x < -50 || bird.x > canvas.width + 50) {
                            bird.vx *= -1;
                        }

                        // ç”»é¢å¤–ã«è½ã¡ãŸé³¥ã¯ä¸Šã«å†é…ç½®
                        if (bird.y - data.camera.y > canvas.height + 200) {
                            bird.y = data.camera.y - 200 - Math.random() * 600;
                            bird.poopTimer = 30 + Math.random() * 120;
                        }

                        // ã†ã‚“ã¡ã‚’è½ã¨ã™
                        bird.poopTimer--;
                        if (bird.poopTimer <= 0) {
                            data.poops.push({
                                x: bird.x + 10,
                                y: bird.y + 10,
                                vy: 0.8  // é€Ÿåº¦ã‚’é…ãã—ãŸï¼ˆ2.0 â†’ 0.8ï¼‰
                            });
                            bird.poopTimer = 150 + Math.random() * 100;
                        }
                    });

                    // ã†ã‚“ã¡ã®æ›´æ–°
                    data.poops.forEach(poop => {
                        poop.y += poop.vy;
                        poop.vy += 0.2; // é‡åŠ›
                    });
                    data.poops = data.poops.filter(poop => poop.y < data.camera.y + canvas.height + 100);

                    // ãƒŸã‚µã‚¤ãƒ«ã®æ›´æ–°
                    data.missiles.forEach(missile => {
                        missile.y -= 8;
                    });
                    data.missiles = data.missiles.filter(missile => missile.y > -50);

                    // ãƒŸã‚µã‚¤ãƒ«ã¨ã†ã‚“ã¡ã®è¡çªåˆ¤å®š
                    data.missiles.forEach((missile, mIndex) => {
                        data.poops.forEach((poop, pIndex) => {
                            if (
                                missile.x > poop.x - 15 &&
                                missile.x < poop.x + 15 &&
                                missile.y > poop.y - 15 &&
                                missile.y < poop.y + 15
                            ) {
                                playSound('hit');
                                data.scoreBonus += 100;
                                data.missiles.splice(mIndex, 1);
                                data.poops.splice(pIndex, 1);
                            }
                        });
                    });

                    // ãƒŸã‚µã‚¤ãƒ«ã¨é³¥ã®è¡çªåˆ¤å®š
                    data.missiles.forEach((missile, mIndex) => {
                        data.birds.forEach((bird, bIndex) => {
                            if (
                                missile.x > bird.x - 10 &&
                                missile.x < bird.x + bird.size + 10 &&
                                missile.y > bird.y - 10 &&
                                missile.y < bird.y + bird.size + 10
                            ) {
                                playSound('hit');
                                data.scoreBonus += 100;
                                data.missiles.splice(mIndex, 1);
                                data.birds.splice(bIndex, 1);
                            }
                        });
                    });

                    // é³¥ã¨ã®è¡çªåˆ¤å®š
                    data.birds.forEach(bird => {
                        const birdScreenY = bird.y - data.camera.y;
                        if (
                            Math.abs(birdScreenY - (data.player.y - data.camera.y)) < canvas.height &&
                            data.player.x + data.player.width > bird.x &&
                            data.player.x < bird.x + bird.size &&
                            data.player.y + data.player.height > bird.y &&
                            data.player.y < bird.y + bird.size
                        ) {
                            data.player.state = 'falling';
                            playSound('hit');
                            setGameState('gameover');
                        }
                    });

                    // ã†ã‚“ã¡ã¨ã®è¡çªåˆ¤å®š
                    data.poops.forEach(poop => {
                        if (
                            data.player.x + data.player.width > poop.x &&
                            data.player.x < poop.x + 8 &&
                            data.player.y + data.player.height > poop.y &&
                            data.player.y < poop.y + 8
                        ) {
                            data.player.state = 'falling';
                            playSound('hit');
                            setGameState('gameover');
                        }
                    });

                    // è¡çªåˆ¤å®š
                    if (data.player.vy > 0) {
                        data.platforms.forEach(p => {
                            if (
                                data.player.x + data.player.width > p.x &&
                                data.player.x < p.x + p.w &&
                                data.player.y + data.player.height > p.y &&
                                data.player.y + data.player.height < p.y + p.h + 10
                            ) {
                                data.player.y = p.y - data.player.height;
                                // 2/3ã‚’è¶…ãˆãŸã‚‰ã‚¸ãƒ£ãƒ³ãƒ—åŠ›1.5å€
                                const jumpForce = enableSuperJump ? JUMP_FORCE * 1.5 : JUMP_FORCE;
                                data.player.vy = jumpForce;
                                data.superJumpActive = false;
                                data.player.state = 'jumping';
                                playJumpVoice(characterType);

                                if (p.type === 'goal') {
                                    data.player.state = 'celebrating';
                                    setGameState('win');
                                }
                            }
                        });
                    }

                    // ã‚«ãƒ¡ãƒ©
                    const targetCamY = data.player.y - canvas.height / 2;
                    if (targetCamY < data.camera.y) {
                        data.camera.y = targetCamY;
                    }

                    // ã‚¹ã‚³ã‚¢ï¼ˆ1m=1ç‚¹ï¼‰
                    const currentHeight = Math.max(0, Math.floor(canvas.height - data.player.y));
                    if (currentHeight > data.maxScore) {
                        data.maxScore = currentHeight;
                    }
                    const totalScore = data.maxScore + data.scoreBonus;
                    setScore(totalScore);
                    updatePlayerScore('pyoko', totalScore);

                    // 1/3ã‚’è¶…ãˆãŸã‚‰ãƒŸã‚µã‚¤ãƒ«æ©Ÿèƒ½æœ‰åŠ¹
                    const enableMissile = currentHeight > GOAL_HEIGHT / 3;
                    // 2/3ã‚’è¶…ãˆãŸã‚‰ã‚¸ãƒ£ãƒ³ãƒ—åŠ›1.5å€
                    const enableSuperJump = currentHeight > GOAL_HEIGHT * 2 / 3;

                    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
                    if (data.player.y > data.camera.y + canvas.height + 100) {
                        data.player.state = 'falling';
                        playSound('gameover');
                        setGameState('gameover');
                    }

                    // æç”»ï¼ˆæ°´è‰²èƒŒæ™¯ï¼‰
                    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    grad.addColorStop(0, '#87CEEB');
                    grad.addColorStop(1, '#B0E0E6');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // é›²æç”»
                    data.clouds.forEach(c => {
                        const cloudY = c.y - data.camera.y;
                        if (cloudY > -100 && cloudY < canvas.height + 100) {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                            ctx.beginPath();
                            ctx.arc(c.x, cloudY, c.size, 0, Math.PI * 2);
                            ctx.arc(c.x + c.size * 0.6, cloudY - c.size * 0.3, c.size * 0.8, 0, Math.PI * 2);
                            ctx.arc(c.x + c.size * 1.1, cloudY + c.size * 0.1, c.size * 0.7, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });

                    // é³¥æç”»
                    data.birds.forEach(bird => {
                        const birdY = bird.y - data.camera.y;
                        if (birdY > -100 && birdY < canvas.height + 100) {
                            ctx.fillStyle = '#8B4513';
                            ctx.beginPath();
                            ctx.arc(bird.x + 10, birdY + 10, 8, 0, Math.PI * 2);
                            ctx.fill();

                            // ç¿¼
                            ctx.strokeStyle = '#8B4513';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            const wingOffset = Math.sin(Date.now() / 100) * 5;
                            ctx.moveTo(bird.x, birdY + 10);
                            ctx.lineTo(bird.x - 8, birdY + wingOffset);
                            ctx.moveTo(bird.x + 20, birdY + 10);
                            ctx.lineTo(bird.x + 28, birdY + wingOffset);
                            ctx.stroke();
                        }
                    });

                    // ã†ã‚“ã¡æç”»
                    data.poops.forEach(poop => {
                        const poopY = poop.y - data.camera.y;
                        if (poopY > -20 && poopY < canvas.height + 20) {
                            ctx.fillStyle = '#8B4513';
                            ctx.beginPath();
                            ctx.arc(poop.x, poopY, 4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });

                    // ãƒŸã‚µã‚¤ãƒ«æç”»
                    if (enableMissile) {
                        data.missiles.forEach(missile => {
                            const missileScreenY = missile.y - data.camera.y;
                            if (missileScreenY > -20 && missileScreenY < canvas.height + 20) {
                                ctx.fillStyle = '#FF4444';
                                ctx.fillRect(missile.x - 2, missileScreenY - 8, 4, 16);
                                // ç‚
                                ctx.fillStyle = '#FFA500';
                                ctx.beginPath();
                                ctx.moveTo(missile.x - 3, missileScreenY + 10);
                                ctx.lineTo(missile.x + 3, missileScreenY + 10);
                                ctx.lineTo(missile.x, missileScreenY + 15);
                                ctx.closePath();
                                ctx.fill();
                            }
                        });
                    }

                    // è¶³å ´æç”»
                    data.platforms.forEach(p => {
                        const screenY = p.y - data.camera.y;
                        if (screenY > -50 && screenY < canvas.height + 50) {
                            ctx.fillStyle = p.type === 'goal' ? '#FFD93D' : '#65B741';
                            ctx.fillRect(p.x, screenY, p.w, p.h);
                        }
                    });

                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»é–¢æ•°ï¼ˆã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦æç”»ï¼‰
                    const drawPlayer = (x, y, state, animFrame, charType) => {
                        // äººé–“ã¯2å€ã‚µã‚¤ã‚º
                        const scale = charType === 'human' ? 2 : 1;
                        const baseWidth = data.player.width;

                        ctx.save();
                        // ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã®ä¸­å¿ƒã‚’è¨­å®š
                        const pivotX = x + baseWidth / 2;
                        const pivotY = y + baseWidth;
                        ctx.translate(pivotX, pivotY);
                        ctx.scale(scale, scale);
                        ctx.translate(-pivotX, -pivotY);

                        const centerX = x + baseWidth / 2;
                        const screenY = y;

                        if (charType === 'human') {
                            // äººé–“ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
                            if (state === 'celebrating') {
                                ctx.fillStyle = '#FF9800';
                                ctx.fillRect(x + 10, screenY + 12, 14, 16);
                                ctx.fillStyle = '#FFCC99';
                                ctx.beginPath();
                                ctx.arc(centerX, screenY + 8, 7, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.fillStyle = '#333';
                                ctx.fillRect(centerX - 4, screenY + 7, 2, 1);
                                ctx.fillRect(centerX + 2, screenY + 7, 2, 1);
                                ctx.strokeStyle = '#333';
                                ctx.lineWidth = 1.5;
                                ctx.beginPath();
                                ctx.arc(centerX, screenY + 10, 3, 0, Math.PI);
                                ctx.stroke();
                                const waveOffset = Math.sin(animFrame / 10) * 3;
                                ctx.strokeStyle = '#FFCC99';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(x + 10, screenY + 15);
                                ctx.lineTo(x + 3, screenY + 8 + waveOffset);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(x + 24, screenY + 15);
                                ctx.lineTo(x + 31, screenY + 8 + waveOffset);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(x + 14, screenY + 28);
                                ctx.lineTo(x + 14, screenY + 32);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(x + 20, screenY + 28);
                                ctx.lineTo(x + 20, screenY + 32);
                                ctx.stroke();
                                ctx.restore();
                                ctx.fillStyle = '#FF6B6B';
                                ctx.font = 'bold 16px sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('ã‚„ã£ãŸãƒ¼ï¼', pivotX, pivotY - baseWidth * scale - 10);
                                return;
                            } else if (state === 'falling') {
                                ctx.fillStyle = '#FF9800';
                                ctx.fillRect(x + 10, screenY + 12, 14, 16);
                                ctx.fillStyle = '#FFCC99';
                                ctx.beginPath();
                                ctx.arc(centerX, screenY + 8, 7, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.strokeStyle = '#333';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(centerX - 5, screenY + 6);
                                ctx.lineTo(centerX - 2, screenY + 9);
                                ctx.moveTo(centerX - 2, screenY + 6);
                                ctx.lineTo(centerX - 5, screenY + 9);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(centerX + 2, screenY + 6);
                                ctx.lineTo(centerX + 5, screenY + 9);
                                ctx.moveTo(centerX + 5, screenY + 6);
                                ctx.lineTo(centerX + 2, screenY + 9);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.arc(centerX, screenY + 13, 3, Math.PI, Math.PI * 2);
                                ctx.stroke();
                                const flailOffset = Math.sin(animFrame / 3) * 8;
                                ctx.strokeStyle = '#FFCC99';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(x + 10, screenY + 15);
                                ctx.lineTo(x + 5 + flailOffset, screenY + 20);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(x + 24, screenY + 15);
                                ctx.lineTo(x + 29 - flailOffset, screenY + 20);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(x + 14, screenY + 28);
                                ctx.lineTo(x + 12 - flailOffset, screenY + 32);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(x + 20, screenY + 28);
                                ctx.lineTo(x + 22 + flailOffset, screenY + 32);
                                ctx.stroke();
                            } else {
                                const bodyOffset = data.player.vy > 0 ? 0 : -2;
                                ctx.fillStyle = '#FF9800';
                                ctx.fillRect(x + 10, screenY + 12 - bodyOffset, 14, 16 + bodyOffset);
                                ctx.fillStyle = '#FFCC99';
                                ctx.beginPath();
                                ctx.arc(centerX, screenY + 8, 7, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.fillStyle = '#333';
                                ctx.beginPath();
                                ctx.arc(centerX - 3, screenY + 7, 2, 0, Math.PI * 2);
                                ctx.arc(centerX + 3, screenY + 7, 2, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.fillRect(centerX - 2, screenY + 11, 4, 1);
                                ctx.strokeStyle = '#FFCC99';
                                ctx.lineWidth = 2;
                                const armAngle = data.player.vy < 0 ? -20 : 10;
                                ctx.beginPath();
                                ctx.moveTo(x + 10, screenY + 15);
                                ctx.lineTo(x + 7, screenY + 18 + armAngle);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(x + 24, screenY + 15);
                                ctx.lineTo(x + 27, screenY + 18 + armAngle);
                                ctx.stroke();
                                const legAngle = data.player.vy < 0 ? 4 : 0;
                                ctx.beginPath();
                                ctx.moveTo(x + 14, screenY + 28);
                                ctx.lineTo(x + 12 + legAngle, screenY + 32);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(x + 20, screenY + 28);
                                ctx.lineTo(x + 22 - legAngle, screenY + 32);
                                ctx.stroke();
                            }
                        } else if (charType === 'bird') {
                            // é³©ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
                            const wingFlap = Math.sin(animFrame / 5) * 5;
                            // ä½“
                            ctx.fillStyle = '#9E9E9E';
                            ctx.beginPath();
                            ctx.ellipse(centerX, screenY + 18, 10, 12, 0, 0, Math.PI * 2);
                            ctx.fill();
                            // é ­
                            ctx.beginPath();
                            ctx.arc(centerX, screenY + 10, 6, 0, Math.PI * 2);
                            ctx.fill();
                            // ãã¡ã°ã—
                            ctx.fillStyle = '#FFA726';
                            ctx.beginPath();
                            ctx.moveTo(centerX, screenY + 10);
                            ctx.lineTo(centerX + 5, screenY + 9);
                            ctx.lineTo(centerX, screenY + 11);
                            ctx.closePath();
                            ctx.fill();
                            // ç›®
                            ctx.fillStyle = '#000';
                            ctx.beginPath();
                            ctx.arc(centerX - 2, screenY + 9, 1.5, 0, Math.PI * 2);
                            ctx.arc(centerX + 2, screenY + 9, 1.5, 0, Math.PI * 2);
                            ctx.fill();
                            // ç¿¼
                            ctx.strokeStyle = '#757575';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(centerX - 10, screenY + 18);
                            ctx.lineTo(centerX - 15, screenY + 15 + wingFlap);
                            ctx.moveTo(centerX + 10, screenY + 18);
                            ctx.lineTo(centerX + 15, screenY + 15 + wingFlap);
                            ctx.stroke();
                            // è¶³
                            ctx.strokeStyle = '#FF6B6B';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(centerX - 3, screenY + 28);
                            ctx.lineTo(centerX - 3, screenY + 32);
                            ctx.moveTo(centerX + 3, screenY + 28);
                            ctx.lineTo(centerX + 3, screenY + 32);
                            ctx.stroke();
                        } else if (charType === 'dog') {
                            // çŠ¬ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
                            // ä½“
                            ctx.fillStyle = '#8D6E63';
                            ctx.fillRect(x + 8, screenY + 18, 18, 10);
                            // é ­
                            ctx.beginPath();
                            ctx.arc(centerX, screenY + 12, 8, 0, Math.PI * 2);
                            ctx.fill();
                            // è€³
                            ctx.beginPath();
                            ctx.ellipse(centerX - 6, screenY + 10, 3, 6, -0.3, 0, Math.PI * 2);
                            ctx.ellipse(centerX + 6, screenY + 10, 3, 6, 0.3, 0, Math.PI * 2);
                            ctx.fill();
                            // ç›®
                            ctx.fillStyle = '#000';
                            ctx.beginPath();
                            ctx.arc(centerX - 3, screenY + 11, 2, 0, Math.PI * 2);
                            ctx.arc(centerX + 3, screenY + 11, 2, 0, Math.PI * 2);
                            ctx.fill();
                            // é¼»
                            ctx.fillStyle = '#000';
                            ctx.beginPath();
                            ctx.arc(centerX, screenY + 15, 2, 0, Math.PI * 2);
                            ctx.fill();
                            // ã—ã£ã½
                            ctx.strokeStyle = '#8D6E63';
                            ctx.lineWidth = 3;
                            const tailWag = Math.sin(animFrame / 5) * 10;
                            ctx.beginPath();
                            ctx.moveTo(x + 26, screenY + 20);
                            ctx.lineTo(x + 30, screenY + 15 + tailWag);
                            ctx.stroke();
                            // è¶³
                            ctx.fillStyle = '#8D6E63';
                            ctx.fillRect(x + 10, screenY + 28, 3, 6);
                            ctx.fillRect(x + 15, screenY + 28, 3, 6);
                            ctx.fillRect(x + 20, screenY + 28, 3, 6);
                        }
                        ctx.restore();
                    };

                    const playerScreenY = data.player.y - data.camera.y;
                    data.player.animFrame = (data.player.animFrame + 0.2) % 360;
                    drawPlayer(data.player.x, playerScreenY, data.player.state, data.player.animFrame, characterType);

                    gameLoopRef.current = requestAnimationFrame(gameLoop);
                };

                gameLoop();

                return () => {
                    if (gameLoopRef.current) {
                        cancelAnimationFrame(gameLoopRef.current);
                    }
                };
            }, [gameState, characterType]);

            // ã‚¿ãƒƒãƒæ“ä½œ
            useEffect(() => {

                // ã‚¹ãƒ¯ã‚¤ãƒ—ç”¨åº§æ¨™
                let touchStartX = null;
                let touchStartY = null;

                const moveCrossy = (dx, dy) => {
                    const data = gameDataRef.current;
                    const crossy = data.crossy;
                    const step = crossy.laneHeight / 1.5;
                    crossy.player.x = Math.max(0, Math.min(window.innerWidth - crossy.player.size, crossy.player.x + dx * step));
                    crossy.player.y = Math.max(0, Math.min(window.innerHeight - crossy.player.size, crossy.player.y + dy * step));
                };

                const handleTouchStart = (e) => {
                    if (e.touches && e.touches.length > 0) {
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                    }
                    e.preventDefault();
                    if (gameState !== 'playing') return;
                    // ã‚¿ãƒƒãƒ—ã®ã¿ã®å³æ™‚æ–¹å‘è»¢æ›ï¼ˆå¾“æ¥é€šã‚Šï¼‰
                    const touchX = e.touches[0].clientX;
                    const touchY = e.touches[0].clientY;
                    const data = gameDataRef.current;
                    if (gameMode === 'crossy') {
                        const centerX = window.innerWidth / 2;
                        const centerY = window.innerHeight / 2;
                        const dx = touchX < centerX ? -1 : 1;
                        const dy = touchY < centerY ? -1 : 1;
                        if (Math.abs(touchX - centerX) > Math.abs(touchY - centerY)) {
                            moveCrossy(dx, 0);
                        } else {
                            moveCrossy(0, dy);
                        }
                        return;
                    }
                    if (gameMode !== 'snake') {
                        if (touchX < window.innerWidth / 2) {
                            data.keys.left = true;
                            data.keys.right = false;
                        } else {
                            data.keys.right = true;
                            data.keys.left = false;
                        }
                    }
                };

                const handleTouchEnd = (e) => {
                    e.preventDefault();
                    const data = gameDataRef.current;
                    data.keys.left = false;
                    data.keys.right = false;

                    // ã‚¹ãƒ¯ã‚¤ãƒ—æ–¹å‘åˆ¤å®š
                    if (gameState !== 'playing' || touchStartX === null || touchStartY === null) return;
                    if (!e.changedTouches || e.changedTouches.length === 0) return;
                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const dx = endX - touchStartX;
                    const dy = endY - touchStartY;
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);
                    // ã‚¹ãƒ¯ã‚¤ãƒ—è·é›¢ãŒä¸€å®šä»¥ä¸Šã®å ´åˆã®ã¿åˆ¤å®š
                    if (absDx < 20 && absDy < 20) return;
                    if (gameMode === 'snake') {
                        const snake = data.snake;
                        if (absDx > absDy) {
                            // æ¨ªã‚¹ãƒ¯ã‚¤ãƒ—
                            if (dx < 0 && snake.direction !== 'right') {
                                snake.nextDirection = 'left';
                            } else if (dx > 0 && snake.direction !== 'left') {
                                snake.nextDirection = 'right';
                            }
                        } else {
                            // ç¸¦ã‚¹ãƒ¯ã‚¤ãƒ—
                            if (dy < 0 && snake.direction !== 'down') {
                                snake.nextDirection = 'up';
                            } else if (dy > 0 && snake.direction !== 'up') {
                                snake.nextDirection = 'down';
                            }
                        }
                    } else if (gameMode === 'crossy') {
                        // ã‚¯ãƒ­ãƒƒã‚·ãƒ¼ã‚‚ã‚¹ãƒ¯ã‚¤ãƒ—ã§ç§»å‹•å¯¾å¿œ
                        if (absDx > absDy) {
                            moveCrossy(dx < 0 ? -1 : 1, 0);
                        } else {
                            moveCrossy(0, dy < 0 ? -1 : 1);
                        }
                    }
                    touchStartX = null;
                    touchStartY = null;
                };

                const handleKeyDown = (e) => {
                    const data = gameDataRef.current;
                    if (gameState !== 'playing') return;

                    if (gameMode === 'snake') {
                        const snake = data.snake;
                        if (e.code === 'ArrowUp' && snake.direction !== 'down') {
                            snake.nextDirection = 'up';
                        }
                        if (e.code === 'ArrowDown' && snake.direction !== 'up') {
                            snake.nextDirection = 'down';
                        }
                        if (e.code === 'ArrowLeft' && snake.direction !== 'right') {
                            snake.nextDirection = 'left';
                        }
                        if (e.code === 'ArrowRight' && snake.direction !== 'left') {
                            snake.nextDirection = 'right';
                        }
                        return;
                    }

                    if (gameMode === 'crossy') {
                        if (e.code === 'ArrowUp') moveCrossy(0, -1);
                        if (e.code === 'ArrowDown') moveCrossy(0, 1);
                        if (e.code === 'ArrowLeft') moveCrossy(-1, 0);
                        if (e.code === 'ArrowRight') moveCrossy(1, 0);
                        return;
                    }

                    if (e.code === 'ArrowLeft') data.keys.left = true;
                    if (e.code === 'ArrowRight') data.keys.right = true;

                    // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ãƒŸã‚µã‚¤ãƒ«ç™ºå°„
                    if (e.code === 'Space' && data.maxScore > GOAL_HEIGHT / 3) {
                        e.preventDefault();
                        data.missiles.push({
                            x: data.player.x + data.player.width / 2,
                            y: data.player.y
                        });
                    }

                    // Sã‚­ãƒ¼ã§ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¸ãƒ£ãƒ³ãƒ—æœ‰åŠ¹åŒ–
                    if (e.code === 'KeyS' && data.maxScore > GOAL_HEIGHT * 2 / 3) {
                        e.preventDefault();
                        data.superJumpActive = true;
                    }
                };

                const handleKeyUp = (e) => {
                    const data = gameDataRef.current;
                    if (e.code === 'ArrowLeft') data.keys.left = false;
                    if (e.code === 'ArrowRight') data.keys.right = false;
                };

                window.addEventListener('touchstart', handleTouchStart, { passive: false });
                window.addEventListener('touchend', handleTouchEnd, { passive: false });
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);

                return () => {
                    window.removeEventListener('touchstart', handleTouchStart);
                    window.removeEventListener('touchend', handleTouchEnd);
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, [gameState]);

            const handleNameSubmit = (e) => {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                const trimmed = nameInput.trim();
                if (!trimmed) return;
                setPlayers(prev => {
                    const exists = prev.some(p => p.name === trimmed);
                    if (exists) return prev;
                    return [...prev, { name: trimmed, pyokoHigh: 0, crossyHigh: 0 }];
                });
                setPlayerName(trimmed);
                setGameState('menu');
            };

            const handleStart = (e) => {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                if (!playerName) {
                    setGameState('name');
                    return;
                }
                // iPhoneã§ã®éŸ³å†ç”Ÿã‚’ç¢ºå®Ÿã«ã™ã‚‹
                if (typeof ensureAudio === 'function') {
                    ensureAudio();
                } else if (gameDataRef.current?.audioCtx?.state === 'suspended') {
                    gameDataRef.current.audioCtx.resume();
                }
                setScore(0);
                setGameState('playing');
            };

            const handleRetry = (e) => {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                // iPhoneã§ã®éŸ³å†ç”Ÿã‚’ç¢ºå®Ÿã«ã™ã‚‹
                if (typeof ensureAudio === 'function') {
                    ensureAudio();
                } else if (gameDataRef.current?.audioCtx?.state === 'suspended') {
                    gameDataRef.current.audioCtx.resume();
                }
                if (gameMode === 'crossy') {
                    const data = gameDataRef.current;
                    data.crossy.level = 1;
                    data.crossy.speedMultiplier = 1;
                    setCrossyLevel(1);
                }
                setScore(0);
                setGameState('playing');
            };

            const handleBackToMenu = (e) => {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                // ç´¯ç©ã‚¹ã‚³ã‚¢ã‚’ãƒªã‚»ãƒƒãƒˆ
                setTotalScore(0);
                setIsNewHighScore(false);
                setHighScoreMessage('');
                const data = gameDataRef.current;
                data.crossy.level = 1;
                data.crossy.speedMultiplier = 1;
                data.crossy.score = 0;
                setCrossyLevel(1);
                setScore(0);
                setGameState('menu');
            };

            const handleNextLevel = (e) => {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                if (typeof ensureAudio === 'function') {
                    ensureAudio();
                }
                const data = gameDataRef.current;
                data.crossy.level += 1;
                data.crossy.speedMultiplier *= 1.2;
                setCrossyLevel(data.crossy.level);
                setScore(0);
                setGameState('playing');
            };

            // æ›´æ–°æ™‚åˆ»ã‚’å–å¾—
            const updateTime = new Date().toLocaleString('ja-JP', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });

            const getRanking = (mode) => {
                return players
                    .map(p => ({
                        name: p.name,
                        score: mode === 'pyoko' ? p.pyokoHigh : mode === 'crossy' ? p.crossyHigh : (p.snakeHigh || 0)
                    }))
                    .filter(p => p.score > 0)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 5);
            };

            const ranking = getRanking(gameMode);
            const topPlayer = ranking[0];

            return (
                <div className="game-container">
                    <canvas ref={canvasRef} />

                    <div className="update-time">æ›´æ–°: {updateTime} / åå‰: {playerName || 'æœªç™»éŒ²'}</div>

                    {gameState === 'playing' && (
                        <>
                            <div className="score">
                                {gameMode === 'pyoko'
                                    ? `ã‚¹ã‚³ã‚¢: ${score}`
                                    : gameMode === 'crossy'
                                    ? `ã‚¹ã‚³ã‚¢: ${score} / é¢: ${crossyLevel} / åˆè¨ˆ: ${totalScore + score}`
                                    : `ã‚¹ã‚³ã‚¢: ${score}ç‚¹`}
                            </div>
                            <div className="high-score">
                                {gameMode === 'pyoko'
                                    ? `ãƒã‚¤ã‚¹ã‚³ã‚¢: ${highScores.pyoko.name || '---'} ${highScores.pyoko.score}m`
                                    : gameMode === 'crossy'
                                    ? `ãƒã‚¤ã‚¹ã‚³ã‚¢: ${highScores.crossy.name || '---'} ${highScores.crossy.score}ç‚¹`
                                    : `ãƒã‚¤ã‚¹ã‚³ã‚¢: ${highScores.snake.name || '---'} ${highScores.snake.score}ç‚¹`}
                            </div>
                            <div className="controls-hint">
                                {gameMode === 'pyoko' && (
                                    <>
                                        PC: çŸ¢å°ã‚­ãƒ¼ / ã‚¹ãƒãƒ›: ç”»é¢å·¦å³ã‚¿ãƒƒãƒ—<br/>
                                        {score > GOAL_HEIGHT / 3 && <span>Space: ãƒŸã‚µã‚¤ãƒ«ç™ºå°„ | </span>}
                                        {score > GOAL_HEIGHT * 2 / 3 && <span>S: ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¸ãƒ£ãƒ³ãƒ—</span>}
                                    </>
                                )}
                                {gameMode === 'crossy' && (
                                    <>
                                        PC: çŸ¢å°ã‚­ãƒ¼ / ã‚¹ãƒãƒ›: ç”»é¢ã‚¿ãƒƒãƒ—ã§æ–¹å‘ç§»å‹•
                                    </>
                                )}
                                {gameMode === 'snake' && (
                                    <>
                                        PC: çŸ¢å°ã‚­ãƒ¼ / ã‚¹ãƒãƒ›: ç”»é¢ã‚¿ãƒƒãƒ—ã§æ–¹å‘ç§»å‹•
                                    </>
                                )}
                            </div>
                        </>
                    )}

                    <div className="ui-overlay">
                        {gameState === 'title' && (
                            <div className="message-box" style={{background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', border: 'none', padding: '50px 60px'}}>
                                <h1 style={{fontSize: '48px', color: 'white', textShadow: '3px 3px 6px rgba(0,0,0,0.3)', marginBottom: '20px'}}>
                                    ğŸ  ãŠå®¶ã¸å¸°ã‚ã†
                                </h1>
                                <p style={{color: 'rgba(255,255,255,0.9)', fontSize: '18px', marginBottom: '10px'}}>
                                    ğŸ¶ ğŸ¦ ğŸ‘¤
                                </p>
                                <p style={{color: 'rgba(255,255,255,0.8)', fontSize: '14px', marginBottom: '30px'}}>
                                    ã‚¸ãƒ£ãƒ³ãƒ—ã§ãŠå®¶ã‚’ç›®æŒ‡ãã†ï¼
                                </p>
                                <button
                                    className="btn"
                                    style={{fontSize: '28px', padding: '20px 60px', background: '#FFD93D', color: '#333', boxShadow: '0 5px 0 #E6B800'}}
                                    onTouchEnd={(e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        setGameState('menu');
                                    }}
                                    onClick={() => setGameState('menu')}
                                >
                                    ã‚¿ãƒƒãƒ—ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ
                                </button>
                                <p style={{color: 'rgba(255,255,255,0.6)', fontSize: '12px', marginTop: '20px'}}>
                                    v1.0 Â© 2026
                                </p>
                            </div>
                        )}

                        {gameState === 'name' && (
                            <div className="message-box">
                                <h1>ğŸ“ åå‰ç™»éŒ²</h1>
                                <p>ã‚²ãƒ¼ãƒ ã‚’å§‹ã‚ã‚‹å‰ã«åå‰ã‚’é¸æŠã¾ãŸã¯æ–°è¦ç™»éŒ²ã—ã¦ãã ã•ã„ã€‚</p>
                                {players.length > 0 && (
                                    <div className="menu-buttons" style={{ marginBottom: '12px' }}>
                                        {players.map((p) => (
                                            <button
                                                key={p.name}
                                                className="btn secondary"
                                                onTouchEnd={(e) => {
                                                    e.preventDefault();
                                                    e.stopPropagation();
                                                    setPlayerName(p.name);
                                                    setNameInput(p.name);
                                                    setGameState('menu');
                                                }}
                                                onClick={() => {
                                                    setPlayerName(p.name);
                                                    setNameInput(p.name);
                                                    setGameState('menu');
                                                }}
                                            >
                                                {p.name} ã‚’é¸æŠ
                                            </button>
                                        ))}
                                    </div>
                                )}
                                <input
                                    className="name-input"
                                    type="text"
                                    placeholder="åå‰"
                                    value={nameInput}
                                    onChange={(e) => setNameInput(e.target.value)}
                                />
                                <button
                                    className="btn"
                                    onTouchEnd={(e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        handleNameSubmit(e);
                                    }}
                                    onClick={handleNameSubmit}
                                >
                                    æ–°è¦ç™»éŒ²ã—ã¦é€²ã‚€
                                </button>
                            </div>
                        )}

                        {gameState === 'menu' && (
                            <div className="message-box">
                                <h1>ğŸ® ã‚²ãƒ¼ãƒ ã‚’é¸ã‚“ã§ã­</h1>
                                <p>{playerName ? `ã‚ˆã†ã“ãã€${playerName}ã•ã‚“ï¼` : 'éŠã³ãŸã„ã‚²ãƒ¼ãƒ ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚'}</p>
                                <div className="menu-buttons">
                                    <button
                                        className="btn"
                                        onTouchEnd={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            setGameMode('pyoko');
                                            setScore(0);
                                            setGameState('character');
                                        }}
                                        onClick={() => {
                                            setGameMode('pyoko');
                                            setScore(0);
                                            setGameState('character');
                                        }}
                                    >
                                        ğŸ  ãŠå®¶ã¸å¸°ã‚ã†
                                    </button>
                                    <button
                                        className="btn secondary"
                                        onTouchEnd={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            setGameMode('crossy');
                                            const data = gameDataRef.current;
                                            data.crossy.level = 1;
                                            data.crossy.speedMultiplier = 1;
                                            setCrossyLevel(1);
                                            setScore(0);
                                            setGameState('start');
                                        }}
                                        onClick={() => {
                                            setGameMode('crossy');
                                            const data = gameDataRef.current;
                                            data.crossy.level = 1;
                                            data.crossy.speedMultiplier = 1;
                                            setCrossyLevel(1);
                                            setScore(0);
                                            setGameState('start');
                                        }}
                                    >
                                        ğŸ¥ ã‚¯ãƒ­ãƒƒã‚·ãƒ¼ãƒ­ãƒ¼ãƒ‰
                                    </button>
                                    <button
                                        className="btn secondary"
                                        style={{background: '#4CAF50', boxShadow: '0 5px 0 #388E3C'}}
                                        onTouchEnd={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            setGameMode('snake');
                                            setScore(0);
                                            setGameState('start');
                                        }}
                                        onClick={() => {
                                            setGameMode('snake');
                                            setScore(0);
                                            setGameState('start');
                                        }}
                                    >
                                        ğŸ ã‚¹ãƒãƒ¼ã‚¯ã‚²ãƒ¼ãƒ 
                                    </button>
                                </div>
                            </div>
                        )}

                        {gameState === 'character' && (
                            <div className="message-box">
                                <h1>ğŸ­ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’é¸ã‚“ã§ã­</h1>
                                <p>å¥½ããªã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’é¸æŠã—ã¦ãã ã•ã„</p>
                                <div className="menu-buttons">
                                    <button
                                        className="btn"
                                        onTouchEnd={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            setCharacterType('human');
                                            setGameState('start');
                                        }}
                                        onClick={() => {
                                            setCharacterType('human');
                                            setGameState('start');
                                        }}
                                    >
                                        ğŸ§‘ äººé–“
                                    </button>
                                    <button
                                        className="btn secondary"
                                        onTouchEnd={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            setCharacterType('bird');
                                            setGameState('start');
                                        }}
                                        onClick={() => {
                                            setCharacterType('bird');
                                            setGameState('start');
                                        }}
                                    >
                                        ğŸ•Šï¸ é³©
                                    </button>
                                    <button
                                        className="btn secondary"
                                        onTouchEnd={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            setCharacterType('dog');
                                            setGameState('start');
                                        }}
                                        onClick={() => {
                                            setCharacterType('dog');
                                            setGameState('start');
                                        }}
                                    >
                                        ğŸ• çŠ¬
                                    </button>
                                </div>
                            </div>
                        )}

                        {gameState === 'start' && (
                            <div className="message-box">
                                <h1>{gameMode === 'pyoko' ? 'ğŸ  ãŠå®¶ã¸å¸°ã‚ã†' : gameMode === 'crossy' ? 'ğŸ¥ ã‚¯ãƒ­ãƒƒã‚·ãƒ¼ãƒ­ãƒ¼ãƒ‰' : 'ğŸ ã‚¹ãƒãƒ¼ã‚¯ã‚²ãƒ¼ãƒ '}</h1>
                                <p className="version">v1.0 Reactç‰ˆ</p>
                                {gameMode === 'pyoko' && <p>ã‚¸ãƒ£ãƒ³ãƒ—ã—ã¦6000mä¸Šã®ãŠå®¶ã‚’ç›®æŒ‡ãã†ï¼</p>}
                                {gameMode === 'crossy' && (
                                    <p>
                                        è»Šã‚’é¿ã‘ã¦ä¸Šã¸é€²ã‚‚ã†ï¼<br/>
                                        ç¾åœ¨ã®é¢: {crossyLevel} / è»Šé€Ÿåº¦ x{gameDataRef.current.crossy.speedMultiplier.toFixed(2)}
                                    </p>
                                )}
                                {gameMode === 'snake' && (
                                    <p>
                                        ã‚Šã‚“ã”ğŸã‚’é£Ÿã¹ã¦è›‡ã‚’é•·ãã—ã‚ˆã†ï¼<br/>
                                        å£ã‚„è‡ªåˆ†ã«ã¶ã¤ã‹ã‚‰ãªã„ã‚ˆã†ã«ï¼
                                    </p>
                                )}
                                <button
                                    className="btn"
                                    onTouchEnd={(e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        handleStart(e);
                                    }}
                                    onClick={handleStart}
                                >
                                    ã‚¹ã‚¿ãƒ¼ãƒˆï¼
                                </button>
                            </div>
                        )}

                        {gameState === 'gameover' && (
                            <div className="message-box">
                                <h1 style={{color: '#FF6B6B'}}>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h1>
                                {gameMode === 'pyoko' && <p>åˆ°é”é«˜ã•: {score}m</p>}
                                {gameMode === 'crossy' && (
                                    <>
                                        <p>é¢: {crossyLevel}</p>
                                        <p style={{fontSize: '20px', fontWeight: 'bold'}}>åˆè¨ˆã‚¹ã‚³ã‚¢: {totalScore + score}ç‚¹</p>
                                    </>
                                )}
                                {gameMode === 'snake' && (
                                    <p style={{fontSize: '20px', fontWeight: 'bold'}}>ã‚¹ã‚³ã‚¢: {score}ç‚¹</p>
                                )}
                                {ranking.length > 0 ? (
                                    <div>
                                        <p>ğŸ† ãƒã‚¤ã‚¹ã‚³ã‚¢ãƒ©ãƒ³ã‚­ãƒ³ã‚°</p>
                                        {ranking.map((r, i) => (
                                            <p key={`${r.name}-${i}`}>{i + 1}. {r.name} - {r.score}{gameMode === 'pyoko' ? 'm' : 'ç‚¹'}</p>
                                        ))}
                                        {topPlayer && <p>ãƒˆãƒƒãƒ—ã®{topPlayer.name}ã•ã‚“ã€ç¥ãƒ¬ãƒ™ãƒ«ã§ã™ï¼</p>}
                                    </div>
                                ) : (
                                    <p>ã¾ã ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>
                                )}
                                <div className="menu-buttons">
                                    <button
                                        className="btn"
                                        onTouchEnd={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            handleRetry(e);
                                        }}
                                        onClick={handleRetry}
                                    >
                                        ã‚‚ã†ä¸€å›ï¼
                                    </button>
                                    <button
                                        className="btn secondary"
                                        onTouchEnd={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            handleBackToMenu(e);
                                        }}
                                        onClick={handleBackToMenu}
                                    >
                                        ã‚²ãƒ¼ãƒ é¸æŠã¸
                                    </button>
                                </div>
                            </div>
                        )}

                        {gameState === 'win' && (
                            <div className="message-box">
                                <h1 style={{color: '#4ECDC4'}}>
                                    {gameMode === 'pyoko' ? 'ğŸ‰ ãŸã ã„ã¾ã£ï¼' : 'ğŸ‰ é¢ã‚¯ãƒªã‚¢ï¼'}
                                </h1>
                                {gameMode === 'pyoko' && (
                                    <>
                                        <p>ç„¡äº‹ã«ãŠå®¶ã«å¸°ã‚Œã¾ã—ãŸï¼</p>
                                        <p>åˆ°é”é«˜ã•: {score}m</p>
                                    </>
                                )}
                                {gameMode === 'crossy' && (
                                    <>
                                        <p style={{fontSize: '18px', fontWeight: 'bold'}}>
                                            é¢{crossyLevel}ã‚¯ãƒªã‚¢ï¼ ãƒœãƒ¼ãƒŠã‚¹ +{crossyLevel * 10}ç‚¹
                                        </p>
                                        <p style={{fontSize: '24px', color: '#FF6B6B', fontWeight: 'bold'}}>
                                            åˆè¨ˆã‚¹ã‚³ã‚¢: {totalScore}ç‚¹
                                        </p>
                                        {isNewHighScore && (
                                            <p style={{fontSize: '20px', color: '#FFD700', fontWeight: 'bold', animation: 'pulse 0.5s infinite'}}>
                                                ğŸŠ æ–°è¨˜éŒ²é”æˆï¼ ğŸŠ<br/>
                                                {highScoreMessage}
                                            </p>
                                        )}
                                        <p style={{marginTop: '10px'}}>æ¬¡ã®é¢ã¸è‡ªå‹•ã§é€²ã¿ã¾ã™...</p>
                                    </>
                                )}
                                {ranking.length > 0 ? (
                                    <div>
                                        <p>ğŸ† ãƒã‚¤ã‚¹ã‚³ã‚¢ãƒ©ãƒ³ã‚­ãƒ³ã‚°</p>
                                        {ranking.map((r, i) => (
                                            <p key={`${r.name}-${i}`}>{i + 1}. {r.name} - {r.score}{gameMode === 'pyoko' ? 'm' : 'ç‚¹'}</p>
                                        ))}
                                        {topPlayer && !isNewHighScore && <p>ãƒˆãƒƒãƒ—ã®{topPlayer.name}ã•ã‚“ã€å¤©æ‰ã™ãã¾ã™ï¼</p>}
                                    </div>
                                ) : (
                                    <p>ã¾ã ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>
                                )}
                                {gameMode === 'pyoko' && (
                                    <>
                                        <button
                                            className="btn"
                                            onTouchEnd={(e) => {
                                                e.preventDefault();
                                                e.stopPropagation();
                                                handleRetry(e);
                                            }}
                                            onClick={handleRetry}
                                        >
                                            ã¾ãŸéŠã¶
                                        </button>
                                        <button
                                            className="btn secondary"
                                            onTouchEnd={(e) => {
                                                e.preventDefault();
                                                e.stopPropagation();
                                                setGameState('menu');
                                            }}
                                            onClick={() => setGameState('menu')}
                                        >
                                            ã‚²ãƒ¼ãƒ é¸æŠã¸
                                        </button>
                                    </>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<Game />);
    </script>
</body>
</html>
